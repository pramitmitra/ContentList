#! /bin/ksh
# Script generated by software licensed from Ab Initio.
# Use and disclosure are subject to Ab Initio confidentiality and license terms.
export AB_HOME;AB_HOME=${AB_HOME:-/legato/softlib/abinitio/abinitio-V3-1-4}
export MPOWERHOME;MPOWERHOME="$AB_HOME"
export AB_COMPONENTS;AB_COMPONENTS="$AB_HOME"'/Projects/root/components'
export PATH
typeset _ab_uname=`uname`
case "$_ab_uname" in
Windows_* )
    PATH="$AB_HOME/bin;$PATH" ;;
CYGWIN_* )
    PATH="`cygpath "$AB_HOME"`/bin:/usr/local/bin:/usr/bin:/bin:$PATH" ;;
* )
    PATH="$AB_HOME/bin:$PATH" ;;
esac
unset ENV
export AB_REPORT;AB_REPORT=${AB_REPORT:-'monitor=300 processes scroll=true'}
unset GDE_EXECUTION

export AB_COMPATIBILITY;AB_COMPATIBILITY=3.1.4.4

# Deployed execution script for graph "single_td_unload", compiled at Tuesday, October 08, 2013 14:52:09 using GDE version 3.0.3.1
export AB_JOB;AB_JOB=${AB_JOB_PREFIX:-""}single_td_unload
# Begin Ab Initio shell utility functions

: ${_ab_uname:=$(uname)}

function __AB_INVOKE_PROJECT
{
  typeset _AB_PROJECT_KSH="$1" ; shift
  typeset _AB_PROJECT_DIR="$1" ; shift
  typeset _AB_DEFINE_OR_EXECUTE="$1" ; shift
  typeset _AB_START_OR_END="$1" ; shift
  # Check that the project exists:
  if [ ! -r "$_AB_PROJECT_KSH" ] ; then
    print -r -u2 Warning: Cannot find common sandbox script: "$_AB_PROJECT_KSH"
    if [ ! -z "${_AB_CALLING_PROJECT:=}" ] ; then
      print -r -u2 Please check the common sandbox settings for the calling project: "$_AB_CALLING_PROJECT"
    fi
  fi
  if [ $# -gt 0 ] ; then
    . "$_AB_PROJECT_KSH" "$_AB_PROJECT_DIR" "$_AB_DEFINE_OR_EXECUTE" "$_AB_START_OR_END"  "$@"
  else
    . "$_AB_PROJECT_KSH" "$_AB_PROJECT_DIR" "$_AB_DEFINE_OR_EXECUTE" "$_AB_START_OR_END" 
  fi;
}

function __AB_DOTIT
{
  if [ $# -gt 0 ] ; then
    .  "$@"
  fi
}

function __AB_QUOTEIT {
  typeset queue q qq qed lotsaqs s trail
  q="'"
  qq='"'
  if [ X"$1" = X"" ] ; then
    print $q$q
    return
  fi
  lotsaqs=${q}${qq}${q}${qq}${q}
  if [ ${#1} -ge 10000 ]; then
    print -r -- "$1" | sed "s/$q/$lotsaqs/g; 1s/^/$q/; \$s/\$/$q/"
  else
    queue=${1%$q}
    if [ X"$queue" != X"$1" ] ; then
      trail="${qq}${q}${qq}" 
    else 
      trail=""
    fi
    oldIFS="$IFS"
    IFS=$q
    set -- $queue
    IFS="$oldIFS"
    print -rn "$q$1"
    shift
    for s; do
      print -rn "$lotsaqs$s"
    done
    print -r $q$trail
  fi
}

function __AB_dirname {
    case $_ab_uname in
    Windows_* | CYGWIN_* )
        typeset d='' p="$1"
        # Strip drive letter colon, if present, and put it into d.
        case $p in
        [A-Za-z]:* )
            d=${p%%:*}:
            p=${p#??}
            ;;
        esac
        # Remove trailing separators, though not the last character in the
        # pathname.
        while : true; do
            case $p in
            ?*[/\\] )
                p=${p%[/\\]} ;;
            * )
                break ;;
            esac
        done
        if [[ "$p" = ?*[/\\]* ]] ; then
            print -r -- "$d${p%[/\\]*}"
        elif [[ "$p" = [/\\]* ]] ; then
            print "$d/"
        else
            print "$d." 
        fi
        ;;
    * ) # Unix
        typeset p="$1"
        # Remove trailing separators, though not the last character in the
        # pathname.
        while : true; do
            case $p in
            ?*/ )
                p="${p%/}" ;;
            * )
                break ;;
            esac
        done
        case $p in
        ?*/* )
            print -r -- "${p%/*}" ;;
        /* )
            print / ;;
        * )
            print . ;;
        esac
        ;;
    esac
}

function __AB_concat_pathname {
    case $_ab_uname in
    Windows_* | CYGWIN_* )
        # Does not handle all cases of concatenating partially absolute
        # pathnames, those with only one of a drive letter or an initial
        # separator.
        case $2 in
        [/\\]* | [A-Za-z]:* )
            print -r -- "$2"
            ;;
        * )
            case $1 in
            # Assume that empty string means ".".  Avoid adding a
            # redundant separator.
            '' | *[/\\] )
                print -r -- "$1$2" ;;
            * )
                print -r -- "$1/$2" ;;
            esac
            ;;
        esac
        ;;
    * ) # Unix
        case $2 in
        /* )
            print -r -- "$2"
            ;;
        * )
            case $1 in
            # Assume that empty string means ".".  Avoid adding a
            # redundant separator.
            '' | */ )
                print -r -- "$1$2" ;;
            * )
                print -r -- "$1/$2" ;;
            esac
            ;;
        esac
        ;;
    esac
}

function __AB_COND {
if [ X"$1" = X0  -o X"$1" = Xfalse -o X"$1" = XFalse -o X"$1" = XF -o X"$1" = Xf ] ; then
  print "0"
else
  print "1"
fi
}

# End Ab Initio shell utility functions
export AB_GRAPH_NAME;AB_GRAPH_NAME=single_td_unload

# Host Setup Commands:
. /dw/etl/mstr_cfg/etlenv.setup
_AB_PROXY_DIR=single_td_unload-ProxyDir-$$
rm -rf "${_AB_PROXY_DIR}"
mkdir "${_AB_PROXY_DIR}"
print -r -- "" > "${_AB_PROXY_DIR}"'/GDE-Parameters'
function __AB_CLEANUP_PROXY_FILES
{
   rm -rf "${_AB_PROXY_DIR}"
   rm -rf "${AB_EXTERNAL_PROXY_DIR}"
   return
}
trap '__AB_CLEANUP_PROXY_FILES' EXIT
# Work around pdksh bug: the EXIT handler is not executed upon a signal.
trap '_AB_status=$?; __AB_CLEANUP_PROXY_FILES; exit $_AB_status' HUP INT QUIT TERM
if [ $# -gt 0 -a X"$1" = X"-help" ]; then
print -r -- 'Usage: single_td_unload.ksh <ETL_ID> <JOB_ENV> <FILE_ID> <DATA_FILENAME_TMP> [-DML_FILENAME <DML_FILENAME>] -PARAM1 <PARAM1> -PARAM2 <PARAM2> -PARAM3 <PARAM3> -PARAM4 <PARAM4>'
exit 1
fi

# Command Line Processing
function _AB_PARSE_ARGUMENTS {
   unset ETL_ID
   unset JOB_ENV
   unset FILE_ID
   unset DATA_FILENAME_TMP
   unset DML_FILENAME
   unset PARAM1
   unset PARAM2
   unset PARAM3
   unset PARAM4
   _ab_index_var=0
   if [ $# -gt 0 ]; then
      export ETL_ID;      ETL_ID="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export JOB_ENV;      JOB_ENV="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export FILE_ID;      FILE_ID="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export DATA_FILENAME_TMP;      DATA_FILENAME_TMP="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   while [ $# -gt 0 ]; do
   _ab_kwd="${1}"
   let _ab_index_var=_ab_index_var+1
   shift
   case ${_ab_kwd} in
   # DML_FILENAME - optional dml file name - used to override the default dml file
     -DML_FILENAME )
      export DML_FILENAME;      DML_FILENAME="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
   # PARAM1 - shell interpretation
     -PARAM1 )
      export PARAM1;      PARAM1="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
   # PARAM2 - shell interpretation
     -PARAM2 )
      export PARAM2;      PARAM2="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
   # PARAM3 - shell interpretation
     -PARAM3 )
      export PARAM3;      PARAM3="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
   # PARAM4 - shell interpretation
     -PARAM4 )
      export PARAM4;      PARAM4="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
     -DW_SQL )
      export DW_SQL;      DW_SQL="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
     -CHECK_SQL_FILE )
      export CHECK_SQL_FILE;      CHECK_SQL_FILE="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
     -INPUT_TABLE_SEL )
      export INPUT_TABLE_SEL;      INPUT_TABLE_SEL="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
     -TABLE_ID21 )
      export TABLE_ID21;      TABLE_ID21="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
     -FEXP_LOGTAB )
      export FEXP_LOGTAB;      FEXP_LOGTAB="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
   * )
      if [ X"${_AB_USED_ARGUMENTS[_ab_index_var]}" != X1 ]; then
         print -r -- 'Unexpected command line argument found: '"${_ab_kwd}"
         print -r -- 'Usage: single_td_unload.ksh <ETL_ID> <JOB_ENV> <FILE_ID> <DATA_FILENAME_TMP> [-DML_FILENAME <DML_FILENAME>] -PARAM1 <PARAM1> -PARAM2 <PARAM2> -PARAM3 <PARAM3> -PARAM4 <PARAM4>'
         exit 1
      fi
   esac
   done
}
if [ $# -gt 0 ]; then
   _AB_PARSE_ARGUMENTS "$@"
else
   _AB_PARSE_ARGUMENTS
fi

if [ X"${ETL_ID:-}" = X"" ]; then
   print -r -- 'Required parameter ETL_ID undefined'
   print -r -- 'Usage: single_td_unload.ksh <ETL_ID> <JOB_ENV> <FILE_ID> <DATA_FILENAME_TMP> [-DML_FILENAME <DML_FILENAME>] -PARAM1 <PARAM1> -PARAM2 <PARAM2> -PARAM3 <PARAM3> -PARAM4 <PARAM4>'
   exit 1
fi

if [ X"${JOB_ENV:-}" = X"" ]; then
   print -r -- 'Required parameter JOB_ENV undefined'
   print -r -- 'Usage: single_td_unload.ksh <ETL_ID> <JOB_ENV> <FILE_ID> <DATA_FILENAME_TMP> [-DML_FILENAME <DML_FILENAME>] -PARAM1 <PARAM1> -PARAM2 <PARAM2> -PARAM3 <PARAM3> -PARAM4 <PARAM4>'
   exit 1
fi

if [ X"${FILE_ID:-}" = X"" ]; then
   print -r -- 'Required parameter FILE_ID undefined'
   print -r -- 'Usage: single_td_unload.ksh <ETL_ID> <JOB_ENV> <FILE_ID> <DATA_FILENAME_TMP> [-DML_FILENAME <DML_FILENAME>] -PARAM1 <PARAM1> -PARAM2 <PARAM2> -PARAM3 <PARAM3> -PARAM4 <PARAM4>'
   exit 1
fi

if [ X"${DATA_FILENAME_TMP:-}" = X"" ]; then
   print -r -- 'Required parameter DATA_FILENAME_TMP undefined'
   print -r -- 'Usage: single_td_unload.ksh <ETL_ID> <JOB_ENV> <FILE_ID> <DATA_FILENAME_TMP> [-DML_FILENAME <DML_FILENAME>] -PARAM1 <PARAM1> -PARAM2 <PARAM2> -PARAM3 <PARAM3> -PARAM4 <PARAM4>'
   exit 1
fi
export DML_FILENAME;DML_FILENAME=${DML_FILENAME:-"$ETL_ID"'.read_unload.dml'}
export PARAM1;PARAM1=${PARAM1:-""}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter PARAM1 of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export PARAM2;PARAM2=${PARAM2:-""}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter PARAM2 of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export PARAM3;PARAM3=${PARAM3:-""}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter PARAM3 of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export PARAM4;PARAM4=${PARAM4:-""}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter PARAM4 of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export ETL_CFG_FILE;ETL_CFG_FILE="$DW_CFG"'/'"$ETL_ID"'.cfg'
export SUBJECT_AREA;SUBJECT_AREA=${ETL_ID%%.*}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter SUBJECT_AREA of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export TABLE_ID;TABLE_ID=${ETL_ID##*.}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter TABLE_ID of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export DB_NAME;DB_NAME=$(JOB_ENV_UPPER=$(print $JOB_ENV | tr [:lower:] [:upper:])
  eval print \$DW_${JOB_ENV_UPPER}_DB)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter DB_NAME of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export UNLOAD_UTF8;UNLOAD_UTF8=$(grep "^UNLOAD_UTF8\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter UNLOAD_UTF8 of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export AB_IDB_CONFIG;AB_IDB_CONFIG=$(if [[ $UNLOAD_UTF8 = 1 ]]
  then
     print teradata_${DB_NAME}_utf8.dbc
  else
     print teradata_${DB_NAME}.dbc
  fi
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter AB_IDB_CONFIG of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export AB_JOB;AB_JOB=$(if [ $ETL_ENV ]
then
   print $AB_JOB.$ETL_ID.$FILE_ID.$ETL_ENV.$JOB_ENV
else
   print $AB_JOB.$ETL_ID.$FILE_ID.$JOB_ENV
fi)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter AB_JOB of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export DW_SQL;DW_SQL="$DW_SQL"
export DW_SA_ARC;DW_SA_ARC="$DW_ARC"'/'"$JOB_ENV"'/'"$SUBJECT_AREA"
export DW_SA_DAT;DW_SA_DAT="$DW_DAT"'/'"$JOB_ENV"'/'"$SUBJECT_AREA"
export DW_SA_LOG;DW_SA_LOG="$DW_LOG"'/'"$JOB_ENV"'/'"$SUBJECT_AREA"
export DW_SA_TMP;DW_SA_TMP="$DW_TMP"'/'"$JOB_ENV"'/'"$SUBJECT_AREA"
export FILE_DATETIME;FILE_DATETIME=$(date '+%Y%m%d-%H%M%S')
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter FILE_DATETIME of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export CNDTL_UNLOAD_COMPRESS;CNDTL_UNLOAD_COMPRESS=$(grep "^CNDTL_UNLOAD_COMPRESS\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CNDTL_UNLOAD_COMPRESS of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export BATCH_SEQ_NUM;BATCH_SEQ_NUM=$(( $(<$DW_SA_DAT/$TABLE_ID.unload.batch_seq_num.dat) + 1))
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter BATCH_SEQ_NUM of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export DATA_FILENAME;DATA_FILENAME=$(if [[ $DATA_FILENAME_TMP = "N" ]]
  then
     print $(grep "^DATA_FILENAME\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE.$BATCH_SEQ_NUM)
  else 
     if [[ $CNDTL_UNLOAD_COMPRESS = 1 ]]
     then 
         eval print $DATA_FILENAME_TMP.gz.$BATCH_SEQ_NUM;
     else
         eval print $DATA_FILENAME_TMP.$BATCH_SEQ_NUM;
     fi
  fi
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter DATA_FILENAME of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export OUT_DIR;OUT_DIR=$(grep "^OUT_DIR\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE/$JOB_ENV/$SUBJECT_AREA)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter OUT_DIR of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export WRK_DIR;WRK_DIR=$(grep "^WRK_DIR\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE/$SUBJECT_AREA)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter WRK_DIR of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export LAST_EXTRACT_TYPE;LAST_EXTRACT_TYPE=$(grep "^UNLOAD_LAST_EXTRACT_TYPE\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter LAST_EXTRACT_TYPE of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export CNDTL_LAST_EXTRACT_ROLLUP;CNDTL_LAST_EXTRACT_ROLLUP=$(if [[ $LAST_EXTRACT_TYPE = "R" ]]; then print 1; else print 0; fi)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CNDTL_LAST_EXTRACT_ROLLUP of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export CNDTL_LAST_EXTRACT_VARIABLE;CNDTL_LAST_EXTRACT_VARIABLE=$(if [[ $LAST_EXTRACT_TYPE = "V" ]]; then print 1; else print 0; fi)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CNDTL_LAST_EXTRACT_VARIABLE of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export LAST_EXTRACT_VALUE_FILE;LAST_EXTRACT_VALUE_FILE=$(if [[ $LAST_EXTRACT_TYPE != "N" ]]
  then
     print $DW_SA_DAT/$TABLE_ID.$FILE_ID.last_unload_value.dat
  else
     print a
  fi
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter LAST_EXTRACT_VALUE_FILE of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export FROM_EXTRACT_VALUE;FROM_EXTRACT_VALUE=$(if [[ $LAST_EXTRACT_TYPE != "N" ]]
  then
     print $(<$LAST_EXTRACT_VALUE_FILE)
  fi
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter FROM_EXTRACT_VALUE of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export TO_EXTRACT_VALUE_FUNCTION;TO_EXTRACT_VALUE_FUNCTION=$(if [[ $LAST_EXTRACT_TYPE = "V" ]]
  then
     print $(grep "^UNLOAD_TO_EXTRACT_VALUE_FUNCTION\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE)
  fi
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter TO_EXTRACT_VALUE_FUNCTION of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export TO_EXTRACT_VALUE;TO_EXTRACT_VALUE=$(if [[ $LAST_EXTRACT_TYPE = "V" ]]
  then
     print $($TO_EXTRACT_VALUE_FUNCTION)
  fi
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter TO_EXTRACT_VALUE of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export CREATE_TMP_SQL_FILE;CREATE_TMP_SQL_FILE=$(set -e
  print "cat <<EOF" > $DW_SA_TMP/$TABLE_ID.unload.$FILE_ID.unload.sql.tmp
  cat $DW_SQL/$ETL_ID.unload.sql >> $DW_SA_TMP/$TABLE_ID.unload.$FILE_ID.unload.sql.tmp
  print -- "--END-OF-SQL" >> $DW_SA_TMP/$TABLE_ID.unload.$FILE_ID.unload.sql.tmp
  print "\nEOF" >> $DW_SA_TMP/$TABLE_ID.unload.$FILE_ID.unload.sql.tmp
  set +e)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CREATE_TMP_SQL_FILE of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export INPUT_TABLE_SEL1;INPUT_TABLE_SEL1=$(. $DW_SA_TMP/$TABLE_ID.unload.$FILE_ID.unload.sql.tmp)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter INPUT_TABLE_SEL1 of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export CHECK_SQL_FILE;CHECK_SQL_FILE=$(
set +e
print $INPUT_TABLE_SEL1 | grep "END-OF-SQL"
err=$?
set -e

if [ $err -eq 1 ]
then
        print "SQL File is not integrated : $DW_SA_TMP/$TABLE_ID.unload.$FILE_ID.unload.sql.tmp" >&2
        exit 1
fi
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CHECK_SQL_FILE of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export INPUT_TABLE_SEL;INPUT_TABLE_SEL="${INPUT_TABLE_SEL1%%--END-OF-SQL*}"
export INPUT_DML;INPUT_DML="$DW_DML"'/'"$DML_FILENAME"
export EXTRACT_LOG_FILE;EXTRACT_LOG_FILE="$DW_SA_LOG"'/'"$TABLE_ID"'.unload.'"$FILE_ID"'.input_table_extract.'"$FILE_DATETIME"'.log'
export OUTPUT_FILE;OUTPUT_FILE=$(eval print $OUT_DIR/$DATA_FILENAME)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter OUTPUT_FILE of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export ROLLUP_FIELD;ROLLUP_FIELD=$(grep "^UNLOAD_ROLLUP_FIELD\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter ROLLUP_FIELD of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export FEXP_SESSION_MAX_FIRST;FEXP_SESSION_MAX_FIRST=$(grep "^FEXP_SESSION_MAX_FIRST\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter FEXP_SESSION_MAX_FIRST of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export FEXP_SESSION_MIN_SECOND;FEXP_SESSION_MIN_SECOND=$(grep "^FEXP_SESSION_MIN_SECOND\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter FEXP_SESSION_MIN_SECOND of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export FEXP_SLEEP;FEXP_SLEEP=$(grep "^FEXP_SLEEP\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter FEXP_SLEEP of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export FEXP_TENACITY;FEXP_TENACITY=$(grep "^FEXP_TENACITY\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter FEXP_TENACITY of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export TABLE_ID21;TABLE_ID21=${TABLE_ID%${TABLE_ID#?????????????????????}}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter TABLE_ID21 of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export FEXP_LOGTAB;FEXP_LOGTAB=${TABLE_ID21:-$TABLE_ID}_$$_L
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter FEXP_LOGTAB of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export FEXP_LOGFILE;FEXP_LOGFILE=$DW_SA_LOG/$TABLE_ID.unload.$FILE_ID.fast_export.$FILE_DATETIME.log
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter FEXP_LOGFILE of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export REFORMAT_INPUT_DML;REFORMAT_INPUT_DML=$(if [[ -f $DW_DML/$ETL_ID.write_unload.dml ]]
then
        print $DW_DML/$ETL_ID.write_unload.dml
else
        print $INPUT_DML 
fi )
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter REFORMAT_INPUT_DML of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export CNDTL_UNLOAD_REFORMAT;CNDTL_UNLOAD_REFORMAT=$(grep "^CNDTL_UNLOAD_REFORMAT\>" $ETL_CFG_FILE | read PARAM VALUE COMMENT; print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CNDTL_UNLOAD_REFORMAT of single_td_unload', interpretation 'shell'
   exit $mpjret
fi
export REFORMAT_TRANS_FILE;REFORMAT_TRANS_FILE="$DW_XFR"'/'"$ETL_ID"'.reformat_unload.xfr'
export RECORD_COUNT_FILE;RECORD_COUNT_FILE="$DW_SA_TMP"'/'"$TABLE_ID"'.unload.'"$FILE_ID"'.record_count.dat'
. ./${_AB_PROXY_DIR}/GDE-Parameters

#+Script Start+  ==================== Edits in this section are preserved.
if [ -z $LAST_EXTRACT_TYPE ]
then
   print "$0: Error: LAST_EXTRACT_TYPE variable not set"
   exit 4
fi


if [[ $LAST_EXTRACT_TYPE != "N" && -z $FROM_EXTRACT_VALUE ]]
then
   print "$0: Error: FROM_EXTRACT_VALUE variable not set"
   exit 4
fi


if [[ $LAST_EXTRACT_TYPE = "V" && -z $TO_EXTRACT_VALUE ]]
then
   print "$0: Error: TO_EXTRACT_VALUE variable not set"
   exit 4
fi


if [[ $LAST_EXTRACT_TYPE = "R" && -z $ROLLUP_FIELD ]]
then
   print "$0: Error: ROLLUP_FIELD variable not set"
   exit 4
fi

if [ -z $BATCH_SEQ_NUM ]
then
   print "$0: Error: BATCH_SEQ_NUM variable not set"
   exit 4
fi

if [ -z $FEXP_SESSION_MAX_FIRST ]
then
   print "$0: Error: FEXP_SESSION_MAX_FIRST variable not set"
   exit 4
fi

if [ -z $FEXP_SESSION_MIN_SECOND ]
then
   print "$0: Error: FEXP_SESSION_MIN_SECOND variable not set"
   exit 4
fi

if [ -z $FEXP_SLEEP ]
then
   print "$0: Error: FEXP_SLEEP variable not set"
   exit 4
fi

if [ -z $FEXP_TENACITY ]
then
   print "$0: Error: FEXP_TENACITY variable not set"
   exit 4
fi























































































































#+End Script Start+  ====================
# Check that the "mp" program is found correctly on the PATH
case "$_ab_uname" in
  Windows_* )
    _ab_expected_mp=$AB_HOME/bin/mp.exe ;;
  * )
    _ab_expected_mp=$AB_HOME/bin/mp
esac
if [ ! -x "$_ab_expected_mp" ]; then
  print "\n*** ERROR: executable $_ab_expected_mp not found"
  exit 1
fi
_ab_found_mp=$(whence mp)
if [ "$_ab_found_mp" = "" ] || [ "$_ab_found_mp" -ot "$_ab_expected_mp" ] || [ "$_ab_found_mp" -nt "$_ab_expected_mp" ]; then
  if [ "$_ab_found_mp" = "" ]; then
    print "\n*** ERROR: mp not found on PATH"
  else
    case "$_ab_uname" in
      CYGWIN_* )
        _ab_found_mp=`cygpath -m "$_ab_found_mp"` ;;
    esac
    print "\n*** ERROR: Wrong mp found on the PATH: $_ab_found_mp"
    print "           Should be via \$AB_HOME/bin: $_ab_expected_mp"
  fi
  print "\nCheck Setup Script in Host Connections Settings and Script Start in Graph Settings for PATH modifications"
  print "Active PATH=$PATH"
  exit 1
fi
if [ -f "$AB_HOME/bin/ab_catalog_functions.ksh" ]; then . ab_catalog_functions.ksh; fi
mv "${_AB_PROXY_DIR}" "${AB_JOB}"'-single_td_unload-ProxyDir'
_AB_PROXY_DIR="${AB_JOB}"'-single_td_unload-ProxyDir'
print -r -- 'record string("|") node, timestamp, component, subcomponent, event_type; string("|\n") event_text; end' > "${_AB_PROXY_DIR}"'/Input_Table-3.dml'
print -r -- 'void(1)' > "${_AB_PROXY_DIR}"'/Deflate-6.dml'
print -r -- 'out::rollup(in) =
begin
  out.last_extract_value :: (string("\n")) max(in.'"${ROLLUP_FIELD}"');                 
end;' > "${_AB_PROXY_DIR}"'/Get_Max_Value_for_Extract_Field-7.xfr'
print -r -- 'record
  string("\n") last_extract_value;
end;' > "${_AB_PROXY_DIR}"'/Last_Extract_Value_File_1-8.dml'
print -r -- 'record
  string("\n") line;
end;' > "${_AB_PROXY_DIR}"'/Extract_Log_File-9.dml'
print -r -- 'record
  string("UTY8722 ") junk;
  decimal(" total") record_count;
  string("\n") newline = "\n";
end;' > "${_AB_PROXY_DIR}"'/Redefine_Format-10.dml'
print -r -- 'out::rollup(in) =
begin
  out.record_count :: sum(in.record_count);
end;' > "${_AB_PROXY_DIR}"'/Rollup_Record_Counts-11.xfr'
print -r -- 'record
  decimal("\n", 0) record_count;
end;' > "${_AB_PROXY_DIR}"'/Rollup_Record_Counts-12.dml'
print -r -- 'record
  string(1) a;
end;' > "${_AB_PROXY_DIR}"'/Send_Primer_Row_to_Reformat-13.dml'
print -r -- 'out::reformat(in) =
begin
  out.last_extract_value :: $TO_EXTRACT_VALUE;
end;' > "${_AB_PROXY_DIR}"'/Update_Last_Extract_Value_File-14.xfr'

mp job ${AB_JOB}

# Layouts:
mp layout layout1 file:.
mp layout layout2 "$DW_TMP"
mp layout layout3 'file:'"$LAST_EXTRACT_VALUE_FILE"

# Record Formats (Metadata):
mp metadata metadata1 -file "$INPUT_DML"
mp metadata metadata2 -file "${_AB_PROXY_DIR}"'/Input_Table-3.dml'
mp metadata metadata3 -file "$REFORMAT_INPUT_DML"
mp metadata metadata4 -file "${_AB_PROXY_DIR}"'/Deflate-6.dml'
mp metadata metadata5 -file "${_AB_PROXY_DIR}"'/Last_Extract_Value_File_1-8.dml'
mp metadata metadata6 -file "${_AB_PROXY_DIR}"'/Extract_Log_File-9.dml'
mp metadata metadata7 -file "${_AB_PROXY_DIR}"'/Redefine_Format-10.dml'
mp metadata metadata8 -file "${_AB_PROXY_DIR}"'/Rollup_Record_Counts-12.dml'
mp metadata metadata9 -file "${_AB_PROXY_DIR}"'/Send_Primer_Row_to_Reformat-13.dml'

export AB_CATALOG;AB_CATALOG=${AB_CATALOG:-"${XX_CATALOG}"}
# Catalog Usage: Creating temporary catalog using lookup files only
m_rmcatalog -catalog GDE-single_td_unload-${AB_JOB}.cat > /dev/null 2>&1
m_mkcatalog -catalog GDE-single_td_unload-${AB_JOB}.cat
SAVED_CATALOG="${AB_CATALOG}"
export AB_CATALOG;AB_CATALOG='GDE-single_td_unload-'"${AB_JOB}"'.cat'
# 
# Initialize condition variables to user-specified conditions
# 
AB_USERCOND_single_td_unload=1
AB_IS_LIVE_single_td_unload=1
AB_USERCOND_Extract_Log_File=1
AB_IS_LIVE_Extract_Log_File=1
AB_HAS_DATA_Flow_7=1
AB_USERCOND_Filter_Record_Count_Rows=1
AB_IS_LIVE_Filter_Record_Count_Rows=1
AB_HAS_DATA_Flow_8=1
AB_USERCOND_Redefine_Format=1
AB_IS_LIVE_Redefine_Format=1
AB_HAS_DATA_Flow_9=1
AB_USERCOND_Rollup_Record_Counts=1
AB_IS_LIVE_Rollup_Record_Counts=1
AB_HAS_DATA_Flow_10=1
AB_USERCOND_Record_Count_File=1
AB_IS_LIVE_Record_Count_File=1
AB_USERCOND_Input_Table__table_=1
AB_IS_LIVE_Input_Table__table_=1
AB_HAS_DATA_Flow_2=1
AB_HAS_DATA_Flow_1=1
AB_USERCOND_Gather_Extract_Logs=1
AB_IS_LIVE_Gather_Extract_Logs=1
AB_USERCOND_Replicate="$CNDTL_LAST_EXTRACT_ROLLUP"
AB_USERCOND_Replicate=$(__AB_COND "${AB_USERCOND_Replicate}")
AB_IS_LIVE_Replicate=1
AB_HAS_DATA_Flow_11=1
AB_HAS_DATA_Flow_5=1
AB_USERCOND_Reformat="$CNDTL_UNLOAD_REFORMAT"
AB_USERCOND_Reformat=$(__AB_COND "${AB_USERCOND_Reformat}")
AB_IS_LIVE_Reformat=1
AB_HAS_DATA_Flow_13=1
AB_USERCOND_Deflate="$CNDTL_UNLOAD_COMPRESS"
AB_USERCOND_Deflate=$(__AB_COND "${AB_USERCOND_Deflate}")
AB_IS_LIVE_Deflate=1
AB_HAS_DATA_Flow_14=1
AB_USERCOND_Output_File=1
AB_IS_LIVE_Output_File=1
AB_USERCOND_Send_From_Extract_Value_to_Rollup="$CNDTL_LAST_EXTRACT_ROLLUP"
AB_USERCOND_Send_From_Extract_Value_to_Rollup=$(__AB_COND "${AB_USERCOND_Send_From_Extract_Value_to_Rollup}")
AB_IS_LIVE_Send_From_Extract_Value_to_Rollup=1
AB_HAS_DATA_Flow_3=1
AB_USERCOND_Get_Max_Value_for_Extract_Field="$CNDTL_LAST_EXTRACT_ROLLUP"
AB_USERCOND_Get_Max_Value_for_Extract_Field=$(__AB_COND "${AB_USERCOND_Get_Max_Value_for_Extract_Field}")
AB_IS_LIVE_Get_Max_Value_for_Extract_Field=1
AB_HAS_DATA_Flow_6=1
AB_USERCOND_Last_Extract_Value_File_1="$CNDTL_LAST_EXTRACT_ROLLUP"
AB_USERCOND_Last_Extract_Value_File_1=$(__AB_COND "${AB_USERCOND_Last_Extract_Value_File_1}")
AB_IS_LIVE_Last_Extract_Value_File_1=1
AB_USERCOND_Send_Primer_Row_to_Reformat="$CNDTL_LAST_EXTRACT_VARIABLE"
AB_USERCOND_Send_Primer_Row_to_Reformat=$(__AB_COND "${AB_USERCOND_Send_Primer_Row_to_Reformat}")
AB_IS_LIVE_Send_Primer_Row_to_Reformat=1
AB_HAS_DATA_Flow_4=1
AB_USERCOND_Update_Last_Extract_Value_File="$CNDTL_LAST_EXTRACT_VARIABLE"
AB_USERCOND_Update_Last_Extract_Value_File=$(__AB_COND "${AB_USERCOND_Update_Last_Extract_Value_File}")
AB_IS_LIVE_Update_Last_Extract_Value_File=1
AB_HAS_DATA_Flow_12=1
AB_USERCOND_Last_Extract_Value_File="$CNDTL_LAST_EXTRACT_VARIABLE"
AB_USERCOND_Last_Extract_Value_File=$(__AB_COND "${AB_USERCOND_Last_Extract_Value_File}")
AB_IS_LIVE_Last_Extract_Value_File=1
AB_USERCOND_chmod_FEXP_LOGFILE=1
AB_IS_LIVE_chmod_FEXP_LOGFILE=1
# 
# Compute condition variables by considering the conditions of neighboring components
# 
done=false
while [ $done = false ] ; do
   done=true
   Temp="${AB_IS_LIVE_Replicate}"
   let AB_IS_LIVE_Replicate="(AB_USERCOND_Replicate) || (((AB_HAS_DATA_Flow_5) > 1))"
   if [ X"${AB_IS_LIVE_Replicate}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_HAS_DATA_Flow_5}"
   let AB_HAS_DATA_Flow_5="AB_IS_LIVE_Get_Max_Value_for_Extract_Field"
   if [ X"${AB_HAS_DATA_Flow_5}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_IS_LIVE_Reformat}"
   let AB_IS_LIVE_Reformat="AB_USERCOND_Reformat"
   if [ X"${AB_IS_LIVE_Reformat}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_IS_LIVE_Deflate}"
   let AB_IS_LIVE_Deflate="AB_USERCOND_Deflate"
   if [ X"${AB_IS_LIVE_Deflate}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_IS_LIVE_Send_From_Extract_Value_to_Rollup}"
   let AB_IS_LIVE_Send_From_Extract_Value_to_Rollup="(AB_HAS_DATA_Flow_3) && (AB_USERCOND_Send_From_Extract_Value_to_Rollup)"
   if [ X"${AB_IS_LIVE_Send_From_Extract_Value_to_Rollup}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_HAS_DATA_Flow_3}"
   let AB_HAS_DATA_Flow_3="(AB_IS_LIVE_Send_From_Extract_Value_to_Rollup) && (AB_IS_LIVE_Get_Max_Value_for_Extract_Field)"
   if [ X"${AB_HAS_DATA_Flow_3}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_IS_LIVE_Get_Max_Value_for_Extract_Field}"
   let AB_IS_LIVE_Get_Max_Value_for_Extract_Field="(((AB_HAS_DATA_Flow_5) || (AB_HAS_DATA_Flow_3)) && (AB_HAS_DATA_Flow_6)) && (AB_USERCOND_Get_Max_Value_for_Extract_Field)"
   if [ X"${AB_IS_LIVE_Get_Max_Value_for_Extract_Field}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_HAS_DATA_Flow_6}"
   let AB_HAS_DATA_Flow_6="(AB_IS_LIVE_Get_Max_Value_for_Extract_Field) && (AB_IS_LIVE_Last_Extract_Value_File_1)"
   if [ X"${AB_HAS_DATA_Flow_6}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_IS_LIVE_Last_Extract_Value_File_1}"
   let AB_IS_LIVE_Last_Extract_Value_File_1="AB_USERCOND_Last_Extract_Value_File_1"
   if [ X"${AB_IS_LIVE_Last_Extract_Value_File_1}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_IS_LIVE_Send_Primer_Row_to_Reformat}"
   let AB_IS_LIVE_Send_Primer_Row_to_Reformat="(AB_HAS_DATA_Flow_4) && (AB_USERCOND_Send_Primer_Row_to_Reformat)"
   if [ X"${AB_IS_LIVE_Send_Primer_Row_to_Reformat}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_HAS_DATA_Flow_4}"
   let AB_HAS_DATA_Flow_4="(AB_IS_LIVE_Send_Primer_Row_to_Reformat) && (AB_IS_LIVE_Update_Last_Extract_Value_File)"
   if [ X"${AB_HAS_DATA_Flow_4}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_IS_LIVE_Update_Last_Extract_Value_File}"
   let AB_IS_LIVE_Update_Last_Extract_Value_File="((AB_HAS_DATA_Flow_4) && (((AB_HAS_DATA_Flow_12) != 0))) && (AB_USERCOND_Update_Last_Extract_Value_File)"
   if [ X"${AB_IS_LIVE_Update_Last_Extract_Value_File}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_HAS_DATA_Flow_12}"
   let AB_HAS_DATA_Flow_12="(AB_IS_LIVE_Update_Last_Extract_Value_File) && (AB_IS_LIVE_Last_Extract_Value_File)"
   if [ X"${AB_HAS_DATA_Flow_12}" != X"$Temp" ]; then
      done=false
   fi
   Temp="${AB_IS_LIVE_Last_Extract_Value_File}"
   let AB_IS_LIVE_Last_Extract_Value_File="AB_USERCOND_Last_Extract_Value_File"
   if [ X"${AB_IS_LIVE_Last_Extract_Value_File}" != X"$Temp" ]; then
      done=false
   fi
done
# 
if [ X"${AB_VERBOSE_CONDITIONS}" != X"" ]; then
   # 
   # echo condition variables
   # 
   print -r -- 'AB_USERCOND_single_td_unload=1'
   print -r -- 'AB_IS_LIVE_single_td_unload=1'
   print -r -- 'AB_USERCOND_Extract_Log_File=1'
   print -r -- 'AB_IS_LIVE_Extract_Log_File=1'
   print -r -- 'AB_HAS_DATA_Flow_7=1'
   print -r -- 'AB_USERCOND_Filter_Record_Count_Rows=1'
   print -r -- 'AB_IS_LIVE_Filter_Record_Count_Rows=1'
   print -r -- 'AB_HAS_DATA_Flow_8=1'
   print -r -- 'AB_USERCOND_Redefine_Format=1'
   print -r -- 'AB_IS_LIVE_Redefine_Format=1'
   print -r -- 'AB_HAS_DATA_Flow_9=1'
   print -r -- 'AB_USERCOND_Rollup_Record_Counts=1'
   print -r -- 'AB_IS_LIVE_Rollup_Record_Counts=1'
   print -r -- 'AB_HAS_DATA_Flow_10=1'
   print -r -- 'AB_USERCOND_Record_Count_File=1'
   print -r -- 'AB_IS_LIVE_Record_Count_File=1'
   print -r -- 'AB_USERCOND_Input_Table__table_=1'
   print -r -- 'AB_IS_LIVE_Input_Table__table_=1'
   print -r -- 'AB_HAS_DATA_Flow_2=1'
   print -r -- 'AB_HAS_DATA_Flow_1=1'
   print -r -- 'AB_USERCOND_Gather_Extract_Logs=1'
   print -r -- 'AB_IS_LIVE_Gather_Extract_Logs=1'
   print -r -- 'AB_USERCOND_Replicate='"${AB_USERCOND_Replicate}"
   print -r -- 'AB_IS_LIVE_Replicate='"${AB_IS_LIVE_Replicate}"
   print -r -- 'AB_HAS_DATA_Flow_11=1'
   print -r -- 'AB_HAS_DATA_Flow_5='"${AB_HAS_DATA_Flow_5}"
   print -r -- 'AB_USERCOND_Reformat='"${AB_USERCOND_Reformat}"
   print -r -- 'AB_IS_LIVE_Reformat='"${AB_IS_LIVE_Reformat}"
   print -r -- 'AB_HAS_DATA_Flow_13=1'
   print -r -- 'AB_USERCOND_Deflate='"${AB_USERCOND_Deflate}"
   print -r -- 'AB_IS_LIVE_Deflate='"${AB_IS_LIVE_Deflate}"
   print -r -- 'AB_HAS_DATA_Flow_14=1'
   print -r -- 'AB_USERCOND_Output_File=1'
   print -r -- 'AB_IS_LIVE_Output_File=1'
   print -r -- 'AB_USERCOND_Send_From_Extract_Value_to_Rollup='"${AB_USERCOND_Send_From_Extract_Value_to_Rollup}"
   print -r -- 'AB_IS_LIVE_Send_From_Extract_Value_to_Rollup='"${AB_IS_LIVE_Send_From_Extract_Value_to_Rollup}"
   print -r -- 'AB_HAS_DATA_Flow_3='"${AB_HAS_DATA_Flow_3}"
   print -r -- 'AB_USERCOND_Get_Max_Value_for_Extract_Field='"${AB_USERCOND_Get_Max_Value_for_Extract_Field}"
   print -r -- 'AB_IS_LIVE_Get_Max_Value_for_Extract_Field='"${AB_IS_LIVE_Get_Max_Value_for_Extract_Field}"
   print -r -- 'AB_HAS_DATA_Flow_6='"${AB_HAS_DATA_Flow_6}"
   print -r -- 'AB_USERCOND_Last_Extract_Value_File_1='"${AB_USERCOND_Last_Extract_Value_File_1}"
   print -r -- 'AB_IS_LIVE_Last_Extract_Value_File_1='"${AB_IS_LIVE_Last_Extract_Value_File_1}"
   print -r -- 'AB_USERCOND_Send_Primer_Row_to_Reformat='"${AB_USERCOND_Send_Primer_Row_to_Reformat}"
   print -r -- 'AB_IS_LIVE_Send_Primer_Row_to_Reformat='"${AB_IS_LIVE_Send_Primer_Row_to_Reformat}"
   print -r -- 'AB_HAS_DATA_Flow_4='"${AB_HAS_DATA_Flow_4}"
   print -r -- 'AB_USERCOND_Update_Last_Extract_Value_File='"${AB_USERCOND_Update_Last_Extract_Value_File}"
   print -r -- 'AB_IS_LIVE_Update_Last_Extract_Value_File='"${AB_IS_LIVE_Update_Last_Extract_Value_File}"
   print -r -- 'AB_HAS_DATA_Flow_12='"${AB_HAS_DATA_Flow_12}"
   print -r -- 'AB_USERCOND_Last_Extract_Value_File='"${AB_USERCOND_Last_Extract_Value_File}"
   print -r -- 'AB_IS_LIVE_Last_Extract_Value_File='"${AB_IS_LIVE_Last_Extract_Value_File}"
   print -r -- 'AB_USERCOND_chmod_FEXP_LOGFILE=1'
   print -r -- 'AB_IS_LIVE_chmod_FEXP_LOGFILE=1'
fi

# Files:
mp ofile Output_File "$OUTPUT_FILE"
if [ X"${AB_IS_LIVE_Last_Extract_Value_File_1}" != X0 ]; then
   mp ofile Last_Extract_Value_File_1 'file:'"$LAST_EXTRACT_VALUE_FILE"
else
   :
fi
mp ifile Extract_Log_File 'file:'"$EXTRACT_LOG_FILE"
AB_PORT_Extract_Log_File_read=Extract_Log_File.read
AB_METADATA_Extract_Log_File_read=' -metadata metadata6'
mp ofile Record_Count_File 'file:'"$RECORD_COUNT_FILE"
if [ X"${AB_IS_LIVE_Last_Extract_Value_File}" != X0 ]; then
   mp ofile Last_Extract_Value_File 'file:'"$LAST_EXTRACT_VALUE_FILE"
else
   :
fi

# Components in phase 0:
mp db-ter-fast-export Input_Table__table_ "$AB_IDB_CONFIG" -select "${INPUT_TABLE_SEL}" -interface FastExport -field_type_preference variable -column_delimiter '|' -brief -sleep "$FEXP_SLEEP" -tenacity "$FEXP_TENACITY" -sessions "$FEXP_SESSION_MAX_FIRST"' '"$FEXP_SESSION_MIN_SECOND" -logtab_name "$FEXP_LOGTAB" -fexp_logfile "$FEXP_LOGFILE" -layout Output_File
AB_PORT_Input_Table__table__read=Input_Table__table_.read
AB_METADATA_Input_Table__table__read=' -metadata metadata1'
AB_PORT_Input_Table__table__log=Input_Table__table_.log
AB_METADATA_Input_Table__table__log=' -metadata metadata2'
mp logger Gather_Extract_Logs "$EXTRACT_LOG_FILE" Start End -layout layout1
if [ X"${AB_IS_LIVE_Replicate}" != X0 ]; then
   mp broadcast Replicate -layout Output_File
   AB_PORT_Replicate_out=Replicate.out
   AB_METADATA_Replicate_out=' -metadata metadata1'
else
   AB_PORT_Replicate_out="${AB_PORT_Input_Table__table__read}"
   AB_METADATA_Replicate_out="${AB_METADATA_Input_Table__table__read}"
   :
fi
if [ X"${AB_IS_LIVE_Reformat}" != X0 ]; then
   mp reformat-transform Reformat -limit 0 -ramp 0.0 -layout Output_File
   mp add-port Reformat.out.out0 ${REFORMAT_TRANS_FILE:+"$REFORMAT_TRANS_FILE"}
   AB_PORT_Reformat_out_out0=Reformat.out.out0
   AB_METADATA_Reformat_out_out0=' -metadata metadata3'
else
   AB_PORT_Reformat_out_out0="${AB_PORT_Replicate_out}"
   AB_METADATA_Reformat_out_out0="${AB_METADATA_Replicate_out}"
   :
fi
if [ X"${AB_IS_LIVE_Deflate}" != X0 ]; then
   mp broadcast Deflate -compression 1 -layout Output_File
   AB_PORT_Deflate_out=Deflate.out
   AB_METADATA_Deflate_out=' -metadata metadata4'
else
   AB_PORT_Deflate_out="${AB_PORT_Reformat_out_out0}"
   AB_METADATA_Deflate_out="${AB_METADATA_Reformat_out_out0}"
   :
fi
if [ X"${AB_IS_LIVE_Send_From_Extract_Value_to_Rollup}" != X0 ]; then
   mp generate Send_From_Extract_Value_to_Rollup 1 -expression $ROLLUP_FIELD '$FROM_EXTRACT_VALUE' -layout Last_Extract_Value_File_1
   AB_PORT_Send_From_Extract_Value_to_Rollup_out=Send_From_Extract_Value_to_Rollup.out
   AB_METADATA_Send_From_Extract_Value_to_Rollup_out=' -metadata metadata1'
else
   :
fi
if [ X"${AB_IS_LIVE_Get_Max_Value_for_Extract_Field}" != X0 ]; then
   mp hash-rollup Get_Max_Value_for_Extract_Field '{}' "${_AB_PROXY_DIR}"'/Get_Max_Value_for_Extract_Field-7.xfr' -max-core 67108864 -limit 0 -ramp 0.0 -layout Last_Extract_Value_File_1
   AB_PORT_Get_Max_Value_for_Extract_Field_out=Get_Max_Value_for_Extract_Field.out
   AB_METADATA_Get_Max_Value_for_Extract_Field_out=' -metadata metadata5'
else
   :
fi
mp filter chmod_FEXP_LOGFILE $DW_EXE/chmod_td_unload_logfile.ksh -layout layout2
mp checkpoint 0

# Components in phase 1:
mp select-transform Filter_Record_Count_Rows 'string_index(line, "UTY8722") > 0' -limit 0 -ramp 0.0 -layout Record_Count_File
AB_PORT_Filter_Record_Count_Rows_out=Filter_Record_Count_Rows.out
AB_METADATA_Filter_Record_Count_Rows_out=' -metadata metadata6'
mp copy Redefine_Format -layout Record_Count_File
AB_PORT_Redefine_Format_out=Redefine_Format.out
AB_METADATA_Redefine_Format_out=' -metadata metadata7'
mp hash-rollup Rollup_Record_Counts '{}' "${_AB_PROXY_DIR}"'/Rollup_Record_Counts-11.xfr' -max-core 67108864 -limit 0 -ramp 0.0 -layout Record_Count_File
AB_PORT_Rollup_Record_Counts_out=Rollup_Record_Counts.out
AB_METADATA_Rollup_Record_Counts_out=' -metadata metadata8'
mp checkpoint 1

# Components in phase 2:
if [ X"${AB_IS_LIVE_Send_Primer_Row_to_Reformat}" != X0 ]; then
   mp generate Send_Primer_Row_to_Reformat 1 -layout layout3
   AB_PORT_Send_Primer_Row_to_Reformat_out=Send_Primer_Row_to_Reformat.out
   AB_METADATA_Send_Primer_Row_to_Reformat_out=' -metadata metadata9'
else
   :
fi
if [ X"${AB_IS_LIVE_Update_Last_Extract_Value_File}" != X0 ]; then
   mp reformat-transform Update_Last_Extract_Value_File -limit 0 -ramp 0.0 -layout layout3
   let AB_DO_ADD_PORT="AB_HAS_DATA_Flow_12"
   if [ X"${AB_DO_ADD_PORT}" != X0 ]; then
      mp add-port Update_Last_Extract_Value_File.out.out0 ${_AB_PROXY_DIR:+"$_AB_PROXY_DIR"}'/Update_Last_Extract_Value_File-14.xfr'
   fi
   AB_PORT_Update_Last_Extract_Value_File_out_out0=Update_Last_Extract_Value_File.out.out0
   AB_METADATA_Update_Last_Extract_Value_File_out_out0=' -metadata metadata5'
else
   :
fi

# Flows for Entire Graph:
mp fan-in-flow Flow_1 "${AB_PORT_Input_Table__table__log}" Gather_Extract_Logs.in${AB_METADATA_Input_Table__table__log}
let AB_FLOW_CONDITION="AB_IS_LIVE_Replicate"
if [ X"${AB_FLOW_CONDITION}" != X0 ]; then
   mp straight-flow Flow_2 "${AB_PORT_Input_Table__table__read}" Replicate.in${AB_METADATA_Input_Table__table__read}
fi
let AB_FLOW_CONDITION="AB_IS_LIVE_Reformat"
if [ X"${AB_FLOW_CONDITION}" != X0 ]; then
   mp straight-flow Flow_11 "${AB_PORT_Replicate_out}" Reformat.in${AB_METADATA_Replicate_out}
fi
let AB_FLOW_CONDITION="AB_IS_LIVE_Deflate"
if [ X"${AB_FLOW_CONDITION}" != X0 ]; then
   mp straight-flow Flow_13 "${AB_PORT_Reformat_out_out0}" Deflate.in${AB_METADATA_Reformat_out_out0}
fi
mp straight-flow Flow_14 "${AB_PORT_Deflate_out}" Output_File.write${AB_METADATA_Deflate_out}
let AB_FLOW_CONDITION="(AB_IS_LIVE_Get_Max_Value_for_Extract_Field) && (AB_HAS_DATA_Flow_5)"
if [ X"${AB_FLOW_CONDITION}" != X0 ]; then
   mp fan-in-flow Flow_5 "${AB_PORT_Replicate_out}" Get_Max_Value_for_Extract_Field.in${AB_METADATA_Replicate_out}
fi
let AB_FLOW_CONDITION="(AB_IS_LIVE_Get_Max_Value_for_Extract_Field) && (AB_HAS_DATA_Flow_3)"
if [ X"${AB_FLOW_CONDITION}" != X0 ]; then
   mp straight-flow Flow_3 "${AB_PORT_Send_From_Extract_Value_to_Rollup_out}" Get_Max_Value_for_Extract_Field.in${AB_METADATA_Send_From_Extract_Value_to_Rollup_out}
fi
let AB_FLOW_CONDITION="(AB_IS_LIVE_Last_Extract_Value_File_1) && (AB_HAS_DATA_Flow_6)"
if [ X"${AB_FLOW_CONDITION}" != X0 ]; then
   mp straight-flow Flow_6 "${AB_PORT_Get_Max_Value_for_Extract_Field_out}" Last_Extract_Value_File_1.write${AB_METADATA_Get_Max_Value_for_Extract_Field_out}
fi
mp straight-flow Flow_7 "${AB_PORT_Extract_Log_File_read}" Filter_Record_Count_Rows.in${AB_METADATA_Extract_Log_File_read}
mp straight-flow Flow_8 "${AB_PORT_Filter_Record_Count_Rows_out}" Redefine_Format.in${AB_METADATA_Filter_Record_Count_Rows_out}
mp straight-flow Flow_9 "${AB_PORT_Redefine_Format_out}" Rollup_Record_Counts.in${AB_METADATA_Redefine_Format_out}
mp straight-flow Flow_10 "${AB_PORT_Rollup_Record_Counts_out}" Record_Count_File.write${AB_METADATA_Rollup_Record_Counts_out}
let AB_FLOW_CONDITION="(AB_IS_LIVE_Update_Last_Extract_Value_File) && (AB_HAS_DATA_Flow_4)"
if [ X"${AB_FLOW_CONDITION}" != X0 ]; then
   mp straight-flow Flow_4 "${AB_PORT_Send_Primer_Row_to_Reformat_out}" Update_Last_Extract_Value_File.in${AB_METADATA_Send_Primer_Row_to_Reformat_out}
fi
let AB_FLOW_CONDITION="(AB_IS_LIVE_Last_Extract_Value_File) && (AB_HAS_DATA_Flow_12)"
if [ X"${AB_FLOW_CONDITION}" != X0 ]; then
   mp straight-flow Flow_12 "${AB_PORT_Update_Last_Extract_Value_File_out_out0}" Last_Extract_Value_File.write${AB_METADATA_Update_Last_Extract_Value_File_out_out0}
fi

if [ X"${AB_VERBOSE_CONDITIONS}" != X"" ]; then
   print -r -- 'Generated graph:'
   mp show
fi
unset AB_COMM_WAIT
export AB_TRACKING_GRAPH_THUMBPRINT;AB_TRACKING_GRAPH_THUMBPRINT=6912177
mp run
mpjret=$?
unset AB_COMM_WAIT
unset AB_TRACKING_GRAPH_THUMBPRINT
mp reset
m_rmcatalog > /dev/null 2>&1
export XX_CATALOG;XX_CATALOG="${SAVED_CATALOG}"
export AB_CATALOG;AB_CATALOG="${SAVED_CATALOG}"

#+Script End+  ==================== Edits in this section are preserved.
#+End Script End+  ====================

exit $mpjret
