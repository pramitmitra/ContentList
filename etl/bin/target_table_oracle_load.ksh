#! /bin/ksh
# Script generated by software licensed from Ab Initio Software Corporation.
# Use and disclosure are subject to Ab Initio confidentiality and license terms.
export AB_HOME;AB_HOME=${AB_HOME:-/usr/local/abinitio}
export MPOWERHOME;MPOWERHOME="$AB_HOME"
export PATH
typeset _ab_uname=`uname`
case "$_ab_uname" in
Windows_* )
    PATH="$AB_HOME/bin;$PATH" ;;
CYGWIN_* )
    PATH="`cygpath "$AB_HOME"`/bin:/usr/local/bin:/usr/bin:/bin:$PATH" ;;
* )
    PATH="$AB_HOME/bin:$PATH" ;;
esac
unset ENV
export AB_REPORT;AB_REPORT=${AB_REPORT:-'monitor=300 processes scroll=true'}
unset GDE_EXECUTION

export AB_COMPATIBILITY;AB_COMPATIBILITY=2.14.53

# Deployed execution script for graph "target_table_oracle_load", compiled at Friday, July 28, 2006 19:47:56 using GDE version 1.13.11
export AB_JOB;AB_JOB=${AB_JOB_PREFIX:-""}target_table_oracle_load
# Begin Ab Initio shell utility functions

: ${_ab_uname:=$(uname)}

function __AB_INVOKE_PROJECT
{
  typeset _AB_PROJECT_KSH="$1" ; shift
  typeset _AB_PROJECT_DIR="$1" ; shift
  typeset _AB_DEFINE_OR_EXECUTE="$1" ; shift
  typeset _AB_START_OR_END="$1" ; shift
   . "$_AB_PROJECT_KSH" "$_AB_PROJECT_DIR" "$_AB_DEFINE_OR_EXECUTE" "$_AB_START_OR_END"  "$@"
}

function __AB_DOTIT
{
   .  "$@"
}

function __AB_QUOTEIT {
  typeset queue q qq qed lotsaqs s trail
  q="'"
  qq='"'
  if [ X"$1" = X"" ] ; then
    print $q$q
    return
  fi
  queue=${1%$q}
  if [ X"$queue" != X"$1" ] ; then
    trail="${qq}${q}${qq}" 
  else 
    trail=""
  fi
  lotsaqs=${q}${qq}${q}${qq}${q}
  oldIFS="$IFS"
  IFS=$q
  set -- $queue
  IFS="$oldIFS"
  print -rn "$q$1"
  shift
  for s; do
    print -rn "$lotsaqs$s"
  done
  print -r $q$trail
}

function __AB_dirname {
    case $_ab_uname in
    Windows_* | CYGWIN_* )
        typeset d='' p="$1"
        # Strip drive letter colon, if present, and put it into d.
        case $p in
        [A-Za-z]:* )
            d=${p%%:*}:
            p=${p#??}
            ;;
        esac
        # Remove trailing separators, though not the last character in the
        # pathname.
        while : true; do
            case $p in
            ?*[/\\] )
                p=${p%[/\\]} ;;
            * )
                break ;;
            esac
        done
        if [[ "$p" = ?*[/\\]* ]] ; then
            print -r -- "$d${p%[/\\]*}"
        elif [[ "$p" = [/\\]* ]] ; then
            print "$d/"
        else
            print "$d." 
        fi
        ;;
    * ) # Unix
        typeset p="$1"
        # Remove trailing separators, though not the last character in the
        # pathname.
        while : true; do
            case $p in
            ?*/ )
                p="${p%/}" ;;
            * )
                break ;;
            esac
        done
        case $p in
        ?*/* )
            print -r -- "${p%/*}" ;;
        /* )
            print / ;;
        * )
            print . ;;
        esac
        ;;
    esac
}

function __AB_concat_pathname {
    case $_ab_uname in
    Windows_* | CYGWIN_* )
        # Does not handle all cases of concatenating partially absolute
        # pathnames, those with only one of a drive letter or an initial
        # separator.
        case $2 in
        [/\\]* | [A-Za-z]:* )
            print -r -- "$2"
            ;;
        * )
            case $1 in
            # Assume that empty string means ".".  Avoid adding a
            # redundant separator.
            '' | *[/\\] )
                print -r -- "$1$2" ;;
            * )
                print -r -- "$1/$2" ;;
            esac
            ;;
        esac
        ;;
    * ) # Unix
        case $2 in
        /* )
            print -r -- "$2"
            ;;
        * )
            case $1 in
            # Assume that empty string means ".".  Avoid adding a
            # redundant separator.
            '' | */ )
                print -r -- "$1$2" ;;
            * )
                print -r -- "$1/$2" ;;
            esac
            ;;
        esac
        ;;
    esac
}

function __AB_COND {
if [ X"$1" = X0  -o X"$1" = Xfalse -o X"$1" = XFalse -o X"$1" = XF -o X"$1" = Xf ] ; then
  print "0"
else
  print "1"
fi
}

# End Ab Initio shell utility functions
export AB_GRAPH_NAME;AB_GRAPH_NAME=target_table_oracle_load

# Host Setup Commands:
. /dw/etl/mstr_cfg/etlenv.setup
_AB_PROXY_DIR=target_table_oracle_load-ProxyDir-$$
rm -rf "${_AB_PROXY_DIR}"
mkdir "${_AB_PROXY_DIR}"
print -r -- "" > "${_AB_PROXY_DIR}"'/GDE-Parameters'
function __AB_CLEANUP_PROXY_FILES
{
   rm -rf "${_AB_PROXY_DIR}"
   rm -rf "${AB_EXTERNAL_PROXY_DIR}"
   return
}
trap '__AB_CLEANUP_PROXY_FILES' EXIT
# Work around pdksh bug: the EXIT handler is not executed upon a signal.
trap '_AB_status=$?; __AB_CLEANUP_PROXY_FILES; exit $_AB_status' HUP INT QUIT TERM
if [ $# -gt 0 -a X"$1" = X"-help" ]; then
print -r -- 'Usage: target_table_oracle_load.ksh <ETL_ID> <JOB_ENV> <SQL_FILENAME>'
exit 1
fi

# Command Line Processing
function _AB_PARSE_ARGUMENTS {
   unset ETL_ID
   unset JOB_ENV
   unset SQL_FILENAME
   _ab_index_var=0
   if [ $# -gt 0 ]; then
      export ETL_ID;      ETL_ID="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export JOB_ENV;      JOB_ENV="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export SQL_FILENAME;      SQL_FILENAME="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   while [ $# -gt 0 ]; do
   _ab_kwd="${1}"
   let _ab_index_var=_ab_index_var+1
   shift
   case ${_ab_kwd} in
   * )
      if [ X"${_AB_USED_ARGUMENTS[_ab_index_var]}" != X1 ]; then
         print -r -- 'Unexpected command line argument found: '"${_ab_kwd}"
         print -r -- 'Usage: target_table_oracle_load.ksh <ETL_ID> <JOB_ENV> <SQL_FILENAME>'
         exit 1
      fi
   esac
   done
}
_AB_PARSE_ARGUMENTS "$@"

if [ X"${ETL_ID:-}" = X"" ]; then
   print -r -- 'Required parameter ETL_ID undefined'
   print -r -- 'Usage: target_table_oracle_load.ksh <ETL_ID> <JOB_ENV> <SQL_FILENAME>'
   exit 1
fi

if [ X"${JOB_ENV:-}" = X"" ]; then
   print -r -- 'Required parameter JOB_ENV undefined'
   print -r -- 'Usage: target_table_oracle_load.ksh <ETL_ID> <JOB_ENV> <SQL_FILENAME>'
   exit 1
fi

if [ X"${SQL_FILENAME:-}" = X"" ]; then
   print -r -- 'Required parameter SQL_FILENAME undefined'
   print -r -- 'Usage: target_table_oracle_load.ksh <ETL_ID> <JOB_ENV> <SQL_FILENAME>'
   exit 1
fi
export ETL_CFG_FILE;ETL_CFG_FILE="$DW_CFG"'/'"$ETL_ID"'.cfg'
export SUBJECT_AREA;SUBJECT_AREA="${ETL_ID%%.*}"
export TABLE_ID;TABLE_ID="${ETL_ID##*.}"
export AB_JOB;AB_JOB=$(if [ $ETL_ENV ]
then
   print $AB_JOB.$TABLE_ID.${SQL_FILENAME%.sql}.$ETL_ENV.$JOB_ENV
else
   print $AB_JOB.$TABLE_ID.${SQL_FILENAME%.sql}.$JOB_ENV
fi)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter AB_JOB of target_table_oracle_load', interpretation 'shell'
   exit $mpjret
fi
export DB_NAME;DB_NAME=$(JOB_ENV_UPPER=$(print $JOB_ENV | tr [:lower:] [:upper:])
  eval print \$DW_${JOB_ENV_UPPER}_DB)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter DB_NAME of target_table_oracle_load', interpretation 'shell'
   exit $mpjret
fi
export AB_IDB_CONFIG;AB_IDB_CONFIG='oracle_'"${DB_NAME}"'.dbc'
export TNS_NAME;TNS_NAME=$(grep "^db_name\>" $DW_DBC/$AB_IDB_CONFIG | read A TNS_NAME_TMP
  print ${TNS_NAME_TMP#@})
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter TNS_NAME of target_table_oracle_load', interpretation 'shell'
   exit $mpjret
fi
export ORA_USERNAME;ORA_USERNAME=$(grep "^$TNS_NAME\>" $DW_LOGINS/ora_logins.dat | read TNS_NAME ORA_USERNAME ORA_PASSWORD ; print $ORA_USERNAME)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter ORA_USERNAME of target_table_oracle_load', interpretation 'shell'
   exit $mpjret
fi
export ORA_PASSWORD;ORA_PASSWORD=$(grep "^$TNS_NAME\>" $DW_LOGINS/ora_logins.dat | read TNS_NAME ORA_USERNAME ORA_PASSWORD ; print $ORA_PASSWORD)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter ORA_PASSWORD of target_table_oracle_load', interpretation 'shell'
   exit $mpjret
fi
export DW_SA_LOG;DW_SA_LOG="$DW_LOG"'/'"$JOB_ENV"'/'"$SUBJECT_AREA"
export DW_SA_TMP;DW_SA_TMP="$DW_TMP"'/'"$JOB_ENV"'/'"$SUBJECT_AREA"
export FILE_DATETIME;FILE_DATETIME=$(date '+%Y%m%d-%H%M%S')
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter FILE_DATETIME of target_table_oracle_load', interpretation 'shell'
   exit $mpjret
fi
export CREATE_TMP_SQL_FILE;CREATE_TMP_SQL_FILE=$(set -e
  print "cat <<EOF" > $DW_SA_TMP/$TABLE_ID.bt.$SQL_FILENAME.tmp
  cat $DW_SQL/$SQL_FILENAME >> $DW_SA_TMP/$TABLE_ID.bt.$SQL_FILENAME.tmp
  print "EOF" >> $DW_SA_TMP/$TABLE_ID.bt.$SQL_FILENAME.tmp
  set +e)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CREATE_TMP_SQL_FILE of target_table_oracle_load', interpretation 'shell'
   exit $mpjret
fi
export RUN_SQL_FILE;RUN_SQL_FILE=$(. $DW_SA_TMP/$TABLE_ID.bt.$SQL_FILENAME.tmp)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter RUN_SQL_FILE of target_table_oracle_load', interpretation 'shell'
   exit $mpjret
fi
export RUN_SQL_LOGFILE;RUN_SQL_LOGFILE="$DW_SA_LOG"'/'"$TABLE_ID"'.bt.'"${SQL_FILENAME%.sql}"'.'"$FILE_DATETIME"'.log'
(
   # Parameters of Run SQL
   _AB_FILE_NAME__DBConfigFile="$AB_IDB_CONFIG"
   if [ -r "${_AB_FILE_NAME__DBConfigFile}" ]; then
      DBConfigFile=$(< "${_AB_FILE_NAME__DBConfigFile}")
      mpjret=$?
      if [ 0 -ne $mpjret ] ; then
         print -- Error evaluating: 'parameter DBConfigFile of Run_SQL', interpretation 'shell'
         exit $mpjret
      fi
   else
      _AB_DBC_PATH=$(m_db find "${_AB_FILE_NAME__DBConfigFile}" 2>/dev/null)
      mpjret=$?
      if [ 0 -ne $mpjret ] ; then
         print -- Error evaluating: '_AB_DBC_PATH', interpretation 'shell'
         exit $mpjret
      fi
      if [ $? = 0 ]; then
         DBConfigFile=$(< "${_AB_DBC_PATH}")
         mpjret=$?
         if [ 0 -ne $mpjret ] ; then
            print -- Error evaluating: 'parameter DBConfigFile of Run_SQL', interpretation 'shell'
            exit $mpjret
         fi
      else
         print -r -- 'Warning: cannot read '"'""${_AB_FILE_NAME__DBConfigFile}""'"' to define parameter DBConfigFile of Run_SQL'
      fi
   fi
   interface=utility
   SQLFile=$RUN_SQL_FILE
   mpjret=$?
   if [ 0 -ne $mpjret ] ; then
      print -- Error evaluating: 'parameter SQLFile of Run_SQL', interpretation 'shell'
      exit $mpjret
   fi
   print -r -- "${SQLFile}" > "${_AB_PROXY_DIR}"'/Run_SQL-2.sql'
   _AB_FILE_NAME__SQLFile=Run_SQL-2.sql
   print -rn Run_SQL__SQLFile= >>${_AB_PROXY_DIR}/GDE-Parameters
   __AB_QUOTEIT "${SQLFile}" >> ${_AB_PROXY_DIR}/GDE-Parameters
   print -rn _AB_FILE_NAME__Run_SQL__SQLFile= >> ${_AB_PROXY_DIR}/GDE-Parameters
   __AB_QUOTEIT "${_AB_FILE_NAME__SQLFile}" >> ${_AB_PROXY_DIR}/GDE-Parameters
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then exit $mpjret ; fi
. ./${_AB_PROXY_DIR}/GDE-Parameters

#+Script Start+  ==================== Edits in this section are preserved.
#+End Script Start+  ====================
if [ -f "$AB_HOME/bin/ab_catalog_functions.ksh" ]; then . ab_catalog_functions.ksh; fi
mv "${_AB_PROXY_DIR}" "${AB_JOB}"'-target_table_oracle_load-ProxyDir'
_AB_PROXY_DIR="${AB_JOB}"'-target_table_oracle_load-ProxyDir'
print -r -- 'record string("|") node, timestamp, component, subcomponent, event_type; string("|\n") event_text; end' > "${_AB_PROXY_DIR}"'/Run_SQL-3.dml'
print -r -- 'out::reformat(in) =
begin
  out.event_text :: in.event_text;
end;' > "${_AB_PROXY_DIR}"'/Reformat-4.xfr'
print -r -- 'record
  string("\n") event_text;
end;' > "${_AB_PROXY_DIR}"'/Reformat-5.dml'

mp job ${AB_JOB}

# Layouts:
mp layout layout1 "$DW_TMP"

# Record Formats (Metadata):
mp metadata metadata1 -file "${_AB_PROXY_DIR}"'/Run_SQL-3.dml'
mp metadata metadata2 -file "${_AB_PROXY_DIR}"'/Reformat-5.dml'

export AB_CATALOG;AB_CATALOG=${AB_CATALOG:-"${XX_CATALOG}"}
# Catalog Usage: Creating temporary catalog using lookup files only
m_rmcatalog -catalog GDE-target_table_oracle_load-${AB_JOB}.cat > /dev/null 2>&1
m_mkcatalog -catalog GDE-target_table_oracle_load-${AB_JOB}.cat
SAVED_CATALOG="${AB_CATALOG}"
export AB_CATALOG;AB_CATALOG='GDE-target_table_oracle_load-'"${AB_JOB}"'.cat'

# Files:
mp file Run_SQL_Log_File 'file:'"$RUN_SQL_LOGFILE" -flags rdwr,unlink,creat,norollback
mp file Run_SQL_Log_File_Tmp 'file:'"${RUN_SQL_LOGFILE}"'.tmp' -flags wronly,unlink,creat,norollback

# Components in phase 0:
mp db-runsql Run_SQL "$AB_IDB_CONFIG" "${_AB_PROXY_DIR}"'/Run_SQL-2.sql' -interface utility -layout Run_SQL_Log_File
mp checkpoint 0

# Components in phase 1:
mp reformat-transform Reformat -limit 0 -ramp 0.0 -layout Run_SQL_Log_File_Tmp
mp add-port Reformat.out.out0 ${_AB_PROXY_DIR:+"$_AB_PROXY_DIR"}'/Reformat-4.xfr'
mp checkpoint 1

# Components in phase 2:
mp filter Rename_Run_SQL_Log_File_Tmp mv ${RUN_SQL_LOGFILE}.tmp ${RUN_SQL_LOGFILE} -layout layout1

# Flows for Entire Graph:
mp straight-flow Flow_1 Run_SQL.log Run_SQL_Log_File.write -metadata metadata1
mp straight-flow Flow_2 Run_SQL_Log_File.read Reformat.in -metadata metadata1
mp straight-flow Flow_3 Reformat.out.out0 Run_SQL_Log_File_Tmp.write -metadata metadata2

mp run
mpjret=$?
mp reset
m_rmcatalog > /dev/null 2>&1
export XX_CATALOG;XX_CATALOG="${SAVED_CATALOG}"
export AB_CATALOG;AB_CATALOG="${SAVED_CATALOG}"

#+Script End+  ==================== Edits in this section are preserved.
#+End Script End+  ====================

exit $mpjret
