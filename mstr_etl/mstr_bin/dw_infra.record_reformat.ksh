#! /bin/ksh
# Script generated by software licensed from Ab Initio.
# Use and disclosure are subject to Ab Initio confidentiality and license terms.
export AB_HOME;AB_HOME=${AB_HOME:-/legato/softlib/abinitio/abinitio-V3-1-4}
export MPOWERHOME;MPOWERHOME="$AB_HOME"
export AB_COMPONENTS;AB_COMPONENTS="$AB_HOME"'/Projects/root/components'
export PATH
typeset _ab_uname=`uname`
case "$_ab_uname" in
Windows_* )
    PATH="$AB_HOME/bin;$PATH" ;;
CYGWIN_* )
    PATH="`cygpath "$AB_HOME"`/bin:/usr/local/bin:/usr/bin:/bin:$PATH" ;;
* )
    PATH="$AB_HOME/bin:$PATH" ;;
esac
unset ENV
export AB_REPORT;AB_REPORT=${AB_REPORT:-'monitor=60 processes scroll=true'}
unset GDE_EXECUTION

export AB_COMPATIBILITY;AB_COMPATIBILITY=3.1.4.4

# Deployed execution script for graph "dw_infra.record_reformat", compiled at Friday, October 04, 2013 11:03:13 using GDE version 3.0.3.1
export AB_JOB;AB_JOB=${AB_JOB_PREFIX:-""}dw_infra_record_reformat
# Begin Ab Initio shell utility functions

: ${_ab_uname:=$(uname)}

function __AB_INVOKE_PROJECT
{
  typeset _AB_PROJECT_KSH="$1" ; shift
  typeset _AB_PROJECT_DIR="$1" ; shift
  typeset _AB_DEFINE_OR_EXECUTE="$1" ; shift
  typeset _AB_START_OR_END="$1" ; shift
  # Check that the project exists:
  if [ ! -r "$_AB_PROJECT_KSH" ] ; then
    print -r -u2 Warning: Cannot find common sandbox script: "$_AB_PROJECT_KSH"
    if [ ! -z "${_AB_CALLING_PROJECT:=}" ] ; then
      print -r -u2 Please check the common sandbox settings for the calling project: "$_AB_CALLING_PROJECT"
    fi
  fi
  if [ $# -gt 0 ] ; then
    . "$_AB_PROJECT_KSH" "$_AB_PROJECT_DIR" "$_AB_DEFINE_OR_EXECUTE" "$_AB_START_OR_END"  "$@"
  else
    . "$_AB_PROJECT_KSH" "$_AB_PROJECT_DIR" "$_AB_DEFINE_OR_EXECUTE" "$_AB_START_OR_END" 
  fi;
}

function __AB_DOTIT
{
  if [ $# -gt 0 ] ; then
    .  "$@"
  fi
}

function __AB_QUOTEIT {
  typeset queue q qq qed lotsaqs s trail
  q="'"
  qq='"'
  if [ X"$1" = X"" ] ; then
    print $q$q
    return
  fi
  lotsaqs=${q}${qq}${q}${qq}${q}
  if [ ${#1} -ge 10000 ]; then
    print -r -- "$1" | sed "s/$q/$lotsaqs/g; 1s/^/$q/; \$s/\$/$q/"
  else
    queue=${1%$q}
    if [ X"$queue" != X"$1" ] ; then
      trail="${qq}${q}${qq}" 
    else 
      trail=""
    fi
    oldIFS="$IFS"
    IFS=$q
    set -- $queue
    IFS="$oldIFS"
    print -rn "$q$1"
    shift
    for s; do
      print -rn "$lotsaqs$s"
    done
    print -r $q$trail
  fi
}

function __AB_dirname {
    case $_ab_uname in
    Windows_* | CYGWIN_* )
        typeset d='' p="$1"
        # Strip drive letter colon, if present, and put it into d.
        case $p in
        [A-Za-z]:* )
            d=${p%%:*}:
            p=${p#??}
            ;;
        esac
        # Remove trailing separators, though not the last character in the
        # pathname.
        while : true; do
            case $p in
            ?*[/\\] )
                p=${p%[/\\]} ;;
            * )
                break ;;
            esac
        done
        if [[ "$p" = ?*[/\\]* ]] ; then
            print -r -- "$d${p%[/\\]*}"
        elif [[ "$p" = [/\\]* ]] ; then
            print "$d/"
        else
            print "$d." 
        fi
        ;;
    * ) # Unix
        typeset p="$1"
        # Remove trailing separators, though not the last character in the
        # pathname.
        while : true; do
            case $p in
            ?*/ )
                p="${p%/}" ;;
            * )
                break ;;
            esac
        done
        case $p in
        ?*/* )
            print -r -- "${p%/*}" ;;
        /* )
            print / ;;
        * )
            print . ;;
        esac
        ;;
    esac
}

function __AB_concat_pathname {
    case $_ab_uname in
    Windows_* | CYGWIN_* )
        # Does not handle all cases of concatenating partially absolute
        # pathnames, those with only one of a drive letter or an initial
        # separator.
        case $2 in
        [/\\]* | [A-Za-z]:* )
            print -r -- "$2"
            ;;
        * )
            case $1 in
            # Assume that empty string means ".".  Avoid adding a
            # redundant separator.
            '' | *[/\\] )
                print -r -- "$1$2" ;;
            * )
                print -r -- "$1/$2" ;;
            esac
            ;;
        esac
        ;;
    * ) # Unix
        case $2 in
        /* )
            print -r -- "$2"
            ;;
        * )
            case $1 in
            # Assume that empty string means ".".  Avoid adding a
            # redundant separator.
            '' | */ )
                print -r -- "$1$2" ;;
            * )
                print -r -- "$1/$2" ;;
            esac
            ;;
        esac
        ;;
    esac
}

function __AB_COND {
if [ X"$1" = X0  -o X"$1" = Xfalse -o X"$1" = XFalse -o X"$1" = XF -o X"$1" = Xf ] ; then
  print "0"
else
  print "1"
fi
}

# End Ab Initio shell utility functions
export AB_GRAPH_NAME;AB_GRAPH_NAME=dw_infra_record_reformat

# Host Setup Commands:
. /dw/etl/mstr_cfg/etlenv.setup
_AB_PROXY_DIR=dw_infra.record_reformat-ProxyDir-$$
rm -rf "${_AB_PROXY_DIR}"
mkdir "${_AB_PROXY_DIR}"
print -r -- "" > "${_AB_PROXY_DIR}"'/GDE-Parameters'
function __AB_CLEANUP_PROXY_FILES
{
   rm -rf "${_AB_PROXY_DIR}"
   rm -rf "${AB_EXTERNAL_PROXY_DIR}"
   return
}
trap '__AB_CLEANUP_PROXY_FILES' EXIT
# Work around pdksh bug: the EXIT handler is not executed upon a signal.
trap '_AB_status=$?; __AB_CLEANUP_PROXY_FILES; exit $_AB_status' HUP INT QUIT TERM
if [ $# -gt 0 -a X"$1" = X"-help" ]; then
print -r -- 'Usage: dw_infra.record_reformat.ksh <TRGT_ETL_ID> <SRC_BATCH_SEQ_NUM> <SRC_ETL_ID> <SRC_JOB_ENV> <SRC_JOB_TYPE> <SRC_JOB_TYPE_ID> <INPUT_DML_FILENAME> <OUTPUT_DML_FILENAME>'
exit 1
fi

# Command Line Processing
function _AB_PARSE_ARGUMENTS {
   unset TRGT_ETL_ID
   unset SRC_BATCH_SEQ_NUM
   unset SRC_ETL_ID
   unset SRC_JOB_ENV
   unset SRC_JOB_TYPE
   unset SRC_JOB_TYPE_ID
   unset INPUT_DML_FILENAME
   unset OUTPUT_DML_FILENAME
   _ab_index_var=0
   if [ $# -gt 0 ]; then
      export TRGT_ETL_ID;      TRGT_ETL_ID="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export SRC_BATCH_SEQ_NUM;      SRC_BATCH_SEQ_NUM="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export SRC_ETL_ID;      SRC_ETL_ID="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export SRC_JOB_ENV;      SRC_JOB_ENV="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export SRC_JOB_TYPE;      SRC_JOB_TYPE="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export SRC_JOB_TYPE_ID;      SRC_JOB_TYPE_ID="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export INPUT_DML_FILENAME;      INPUT_DML_FILENAME="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   if [ $# -gt 0 ]; then
      export OUTPUT_DML_FILENAME;      OUTPUT_DML_FILENAME="${1}"
      let _ab_index_var=_ab_index_var+1
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      shift
   fi
   while [ $# -gt 0 ]; do
   _ab_kwd="${1}"
   let _ab_index_var=_ab_index_var+1
   shift
   case ${_ab_kwd} in
     -TRGT_IN_DIR )
      export TRGT_IN_DIR;      TRGT_IN_DIR="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
   # CNDTL_EXTRACT_COMPRESS_LEVEL - File Compression Level
     -CNDTL_EXTRACT_COMPRESS_LEVEL )
      export CNDTL_EXTRACT_COMPRESS_LEVEL;      CNDTL_EXTRACT_COMPRESS_LEVEL="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
     -CNDTL_EXTRACT_COMPRESS )
      export CNDTL_EXTRACT_COMPRESS;      CNDTL_EXTRACT_COMPRESS="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
     -CNDTL_EXTRACT_NOT_COMPRESS )
      export CNDTL_EXTRACT_NOT_COMPRESS;      CNDTL_EXTRACT_NOT_COMPRESS="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
     -CNDTL_SRC_EXTRACT_COMPRESS )
      export CNDTL_SRC_EXTRACT_COMPRESS;      CNDTL_SRC_EXTRACT_COMPRESS="${1}"
      _AB_USED_ARGUMENTS[_ab_index_var]=1
      _AB_USED_ARGUMENTS[_ab_index_var+1]=1
      let _ab_index_var=_ab_index_var+1
      shift
      ;;
   * )
      if [ X"${_AB_USED_ARGUMENTS[_ab_index_var]}" != X1 ]; then
         print -r -- 'Unexpected command line argument found: '"${_ab_kwd}"
         print -r -- 'Usage: dw_infra.record_reformat.ksh <TRGT_ETL_ID> <SRC_BATCH_SEQ_NUM> <SRC_ETL_ID> <SRC_JOB_ENV> <SRC_JOB_TYPE> <SRC_JOB_TYPE_ID> <INPUT_DML_FILENAME> <OUTPUT_DML_FILENAME>'
         exit 1
      fi
   esac
   done
}
if [ $# -gt 0 ]; then
   _AB_PARSE_ARGUMENTS "$@"
else
   _AB_PARSE_ARGUMENTS
fi

if [ X"${TRGT_ETL_ID:-}" = X"" ]; then
   print -r -- 'Required parameter TRGT_ETL_ID undefined'
   print -r -- 'Usage: dw_infra.record_reformat.ksh <TRGT_ETL_ID> <SRC_BATCH_SEQ_NUM> <SRC_ETL_ID> <SRC_JOB_ENV> <SRC_JOB_TYPE> <SRC_JOB_TYPE_ID> <INPUT_DML_FILENAME> <OUTPUT_DML_FILENAME>'
   exit 1
fi
export SRC_BATCH_SEQ_NUM;SRC_BATCH_SEQ_NUM=${SRC_BATCH_SEQ_NUM:-"$BATCH_SEQ_NUM"}
export SRC_ETL_ID;SRC_ETL_ID=${SRC_ETL_ID:-"$ETL_ID"}
export SRC_JOB_ENV;SRC_JOB_ENV=${SRC_JOB_ENV:-"$JOB_ENV"}
export SRC_JOB_TYPE;SRC_JOB_TYPE=${SRC_JOB_TYPE:-"$JOB_TYPE"}
export SRC_JOB_TYPE_ID;SRC_JOB_TYPE_ID=${SRC_JOB_TYPE_ID:-"$JOB_TYPE_ID"}
export INPUT_DML_FILENAME;INPUT_DML_FILENAME=${INPUT_DML_FILENAME:-"$SRC_ETL_ID"'.read.dml'}
export OUTPUT_DML_FILENAME;OUTPUT_DML_FILENAME=${OUTPUT_DML_FILENAME:-"$TRGT_ETL_ID"'.read.dml'}
export AB_JOB;AB_JOB="$AB_JOB"'.'"$SRC_ETL_ID"'.'"$TRGT_ETL_ID"
export TRGT_ETL_CFG_FILE;TRGT_ETL_CFG_FILE="$DW_CFG"'/'"$TRGT_ETL_ID"'.cfg'
export TRGT_SUBJECT_AREA;TRGT_SUBJECT_AREA=${TRGT_ETL_ID%%.*}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter TRGT_SUBJECT_AREA of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export TRGT_TABLE_ID;TRGT_TABLE_ID=${TRGT_ETL_ID##*.}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter TRGT_TABLE_ID of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export SRC_ETL_CFG_FILE;SRC_ETL_CFG_FILE="$DW_CFG"'/'"$SRC_ETL_ID"'.cfg'
export SRC_SUBJECT_AREA;SRC_SUBJECT_AREA=${SRC_ETL_ID%%.*}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter SRC_SUBJECT_AREA of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export SRC_TABLE_ID;SRC_TABLE_ID=${SRC_ETL_ID##*.}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter SRC_TABLE_ID of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export CURR_DATETIME;CURR_DATETIME=${CURR_DATETIME:-$(date '+%Y%m%d-%H%M%S')}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CURR_DATETIME of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export CURR_DATE;CURR_DATE=${CURR_DATE:-${CURR_DATETIME%-*}}
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CURR_DATE of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export IS_CATY;IS_CATY=$(grep "^IS_CATY\>" $SRC_ETL_CFG_FILE | read PARAM VALUE COMMENT; print $VALUE)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter IS_CATY of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export IN_DIR;IN_DIR=$(grep "^IN_DIR\>" $SRC_ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE/$SRC_JOB_ENV/$SRC_SUBJECT_AREA)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter IN_DIR of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export TRGT_IN_DIR;TRGT_IN_DIR=$(grep "^IN_DIR\>" $TRGT_ETL_CFG_FILE | read PARAM VALUE COMMENT; eval print $VALUE/$SRC_JOB_ENV/$TRGT_SUBJECT_AREA)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter TRGT_IN_DIR of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export CNDTL_EXTRACT_COMPRESS_LEVEL;CNDTL_EXTRACT_COMPRESS_LEVEL=$(grep "^CNDTL_EXTRACT_COMPRESS_LEVEL\>" $TRGT_ETL_CFG_FILE | read PARAM VALUE COMMENT; print ${VALUE:-""})
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CNDTL_EXTRACT_COMPRESS_LEVEL of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export CNDTL_EXTRACT_COMPRESS;CNDTL_EXTRACT_COMPRESS=$(grep "^CNDTL_EXTRACT_COMPRESS\>" $TRGT_ETL_CFG_FILE | read PARAM VALUE COMMENT;  print ${VALUE:-0})
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CNDTL_EXTRACT_COMPRESS of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export CNDTL_EXTRACT_NOT_COMPRESS;CNDTL_EXTRACT_NOT_COMPRESS=$(if [[ $CNDTL_EXTRACT_COMPRESS != 1 ]]
  then
     print 1
  else
     print 0
  fi)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CNDTL_EXTRACT_NOT_COMPRESS of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export CNDTL_SRC_EXTRACT_COMPRESS;CNDTL_SRC_EXTRACT_COMPRESS=$(grep "^CNDTL_EXTRACT_COMPRESS\>" $SRC_ETL_CFG_FILE | read PARAM VALUE COMMENT;  print ${VALUE:-0})
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter CNDTL_SRC_EXTRACT_COMPRESS of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export INPUT_FILE;INPUT_FILE=$( INPUT_FILE_TMP=""
   if [ $CNDTL_SRC_EXTRACT_COMPRESS != 1 ]
   then
      COMP_SFX=""
   else
       COMP_SFX=.gz
   fi

   if [ $EXTRACT_PROCESS_TYPE = 'L' ]
   then
      while read FILE_ID DATA_FILENAME OLD_FILENAME DONE_FILENAME
      do
         INPUT_FILE_TMP="$INPUT_FILE_TMP $(eval print $IN_DIR/$DATA_FILENAME.$SRC_BATCH_SEQ_NUM$COMP_SFX)"
      done < $DW_DAT/extract/$SRC_SUBJECT_AREA/$SRC_ETL_ID.sources.lis.$SRC_BATCH_SEQ_NUM
   elif [ $IS_CATY != 1 ]
   then   
      while read FILE_ID DBC_FILE PARALLEL_NUM TABLE_NAME DATA_FILENAME PARAM
      do
         if [[ CNDTL_SRC_EXTRACT_COMPRESS = 1  && -f $(eval print $IN_DIR/$DATA_FILENAME.$SRC_BATCH_SEQ_NUM.Z) ]]
         then
            COMP_SFX=.Z
         fi

         if [ -f $(eval print ${IN_DIR}/.${DATA_FILENAME}.${SRC_BATCH_SEQ_NUM}${COMP_SFX}.mfctl) ]
         then
            INPUT_FILE_TMP="$INPUT_FILE_TMP $(eval print $(m_expand $IN_DIR/$DATA_FILENAME.$SRC_BATCH_SEQ_NUM$COMP_SFX))"
         else
            INPUT_FILE_TMP="$INPUT_FILE_TMP $(eval print $IN_DIR/$DATA_FILENAME.$SRC_BATCH_SEQ_NUM$COMP_SFX)"
         fi
      done < $DW_CFG/$SRC_ETL_ID.sources.lis
   else
      read TABLE_NAME DATA_FILENAME PARAM < $DW_CFG/$SRC_ETL_ID.sources.lis

      while read FILE_ID DBC_FILE
      do
         if [[ CNDTL_SRC_EXTRACT_COMPRESS = 1  && -f $(eval print $IN_DIR/$DATA_FILENAME.$SRC_BATCH_SEQ_NUM.Z) ]]
         then
            COMP_SFX=.Z
         fi

         if [ -f $(eval print ${IN_DIR}/.${DATA_FILENAME}.${SRC_BATCH_SEQ_NUM}${COMP_SFX}.mfctl) ]
         then
            INPUT_FILE_TMP="$INPUT_FILE_TMP $(eval print $(m_expand $IN_DIR/$DATA_FILENAME.$SRC_BATCH_SEQ_NUM$COMP_SFX))"
         else
            INPUT_FILE_TMP="$INPUT_FILE_TMP $(eval print $IN_DIR/$DATA_FILENAME.$SRC_BATCH_SEQ_NUM$COMP_SFX)"
         fi
      done < $DW_CFG/dw_caty.sources.lis
   fi
   print $INPUT_FILE_TMP
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter INPUT_FILE of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export OUTPUT_FILE;OUTPUT_FILE=$( INPUT_FILE_TMP=""
   for fn in $INPUT_FILE
   do
      if [[ ${fn##*.} = 'Z' || ${fn##*.} = 'gz' ]]
      then
         fn=${fn%.*}
      fi

      fn=$(print $fn | sed s/$SRC_TABLE_ID/$TRGT_TABLE_ID/g)

      fn=$TRGT_IN_DIR/${fn##*/}

      if [ $CNDTL_EXTRACT_COMPRESS = 1 ]
      then
         fn=${fn}.gz
      fi

      INPUT_FILE_TMP="$INPUT_FILE_TMP $fn"
   done

   print $INPUT_FILE_TMP
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter OUTPUT_FILE of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export INPUT_DML;INPUT_DML="$DW_DML"'/'"$INPUT_DML_FILENAME"
export OUTPUT_DML;OUTPUT_DML="$DW_DML"'/'"$OUTPUT_DML_FILENAME"
export REFORMAT_XFR_FILE;REFORMAT_XFR_FILE="$DW_XFR"'/'"$TRGT_ETL_ID"'.reformat.xfr'
export LOG_FILE_DIR;LOG_FILE_DIR=$DW_LOG/$SRC_JOB_ENV/$TRGT_SUBJECT_AREA/$TRGT_TABLE_ID/$CURR_DATE
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter LOG_FILE_DIR of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export LOG_FILE;LOG_FILE=$LOG_FILE_DIR/$TRGT_TABLE_ID.$SRC_JOB_TYPE_ID.normalize.$CURR_DATETIME.log
mpjret=$?
if [ 0 -ne $mpjret ] ; then
   print -- Error evaluating: 'parameter LOG_FILE of dw_infra_record_reformat', interpretation 'shell'
   exit $mpjret
fi
export RECORD_COUNT_FILE;RECORD_COUNT_FILE="$TRGT_IN_DIR"'/'"$TRGT_TABLE_ID"'.record_count.dat.'"$SRC_BATCH_SEQ_NUM"
export WATCH_FILE;WATCH_FILE="$DW_WATCH"'/'"$SRC_JOB_ENV"'/'"$TRGT_ETL_ID"'.'"$SRC_JOB_TYPE"'.'"$SRC_BATCH_SEQ_NUM"'.done'
(
   # Parameters of Deflate-1
   condition=$CNDTL_EXTRACT_COMPRESS
   mpjret=$?
   if [ 0 -ne $mpjret ] ; then
      print -- Error evaluating: 'parameter condition of Deflate_1', interpretation 'shell'
      exit $mpjret
   fi
   print -rn Deflate_1__condition= >>${_AB_PROXY_DIR}/GDE-Parameters
   __AB_QUOTEIT "${condition}" >> ${_AB_PROXY_DIR}/GDE-Parameters
   conditionInputPort=in
   conditionOutputPort=out
   condition_interpretation='Replace with flow'
   compression=$CNDTL_EXTRACT_COMPRESS_LEVEL
   mpjret=$?
   if [ 0 -ne $mpjret ] ; then
      print -- Error evaluating: 'parameter compression of Deflate_1', interpretation 'shell'
      exit $mpjret
   fi
   print -rn Deflate_1__compression= >>${_AB_PROXY_DIR}/GDE-Parameters
   __AB_QUOTEIT "${compression}" >> ${_AB_PROXY_DIR}/GDE-Parameters
)
mpjret=$?
if [ 0 -ne $mpjret ] ; then exit $mpjret ; fi
. ./${_AB_PROXY_DIR}/GDE-Parameters

#+Script Start+  ==================== Edits in this section are preserved.
#+End Script Start+  ====================
# Check that the "mp" program is found correctly on the PATH
case "$_ab_uname" in
  Windows_* )
    _ab_expected_mp=$AB_HOME/bin/mp.exe ;;
  * )
    _ab_expected_mp=$AB_HOME/bin/mp
esac
if [ ! -x "$_ab_expected_mp" ]; then
  print "\n*** ERROR: executable $_ab_expected_mp not found"
  exit 1
fi
_ab_found_mp=$(whence mp)
if [ "$_ab_found_mp" = "" ] || [ "$_ab_found_mp" -ot "$_ab_expected_mp" ] || [ "$_ab_found_mp" -nt "$_ab_expected_mp" ]; then
  if [ "$_ab_found_mp" = "" ]; then
    print "\n*** ERROR: mp not found on PATH"
  else
    case "$_ab_uname" in
      CYGWIN_* )
        _ab_found_mp=`cygpath -m "$_ab_found_mp"` ;;
    esac
    print "\n*** ERROR: Wrong mp found on the PATH: $_ab_found_mp"
    print "           Should be via \$AB_HOME/bin: $_ab_expected_mp"
  fi
  print "\nCheck Setup Script in Host Connections Settings and Script Start in Graph Settings for PATH modifications"
  print "Active PATH=$PATH"
  exit 1
fi
if [ -f "$AB_HOME/bin/ab_catalog_functions.ksh" ]; then . ab_catalog_functions.ksh; fi
mv "${_AB_PROXY_DIR}" "${AB_JOB}"'-dw_infra.record_reformat-ProxyDir'
_AB_PROXY_DIR="${AB_JOB}"'-dw_infra.record_reformat-ProxyDir'
print -r -- 'record string("|") node, timestamp, component, subcomponent, event_type; string("|\n") event_text; end' > "${_AB_PROXY_DIR}"'/Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr-4.dml'
print -r -- 'void(1)' > "${_AB_PROXY_DIR}"'/Deflate_1-5.dml'
print -r -- 'record
  string("\n") line;
end;' > "${_AB_PROXY_DIR}"'/Output_log_file-6.dml'
print -r -- 'record
  decimal(" records") rec_cnt = 0;
  string("\n") junk = NULL;
end;' > "${_AB_PROXY_DIR}"'/Redefine_Format_1-7.dml'
print -r -- 'out::rollup(in) =
begin
  out.rec_cnt :: sum(in.rec_cnt);
end;' > "${_AB_PROXY_DIR}"'/Rollup-8.xfr'
print -r -- 'record
  decimal("\n") rec_cnt = 0;
end;' > "${_AB_PROXY_DIR}"'/Rollup-9.dml'

mp job ${AB_JOB}

# Layouts:
mp layout layout1 1
mp layout layout2 file:.

# Record Formats (Metadata):
mp metadata metadata1 -file "$INPUT_DML"
mp metadata metadata2 -file "$OUTPUT_DML"
mp metadata metadata3 -file "${_AB_PROXY_DIR}"'/Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr-4.dml'
mp metadata metadata4 -file "${_AB_PROXY_DIR}"'/Deflate_1-5.dml'
mp metadata metadata5 -file "${_AB_PROXY_DIR}"'/Output_log_file-6.dml'
mp metadata metadata6 -file "${_AB_PROXY_DIR}"'/Redefine_Format_1-7.dml'
mp metadata metadata7 -file "${_AB_PROXY_DIR}"'/Rollup-9.dml'

export AB_CATALOG;AB_CATALOG=${AB_CATALOG:-"${XX_CATALOG}"}
# Catalog Usage: Creating temporary catalog using lookup files only
m_rmcatalog -catalog GDE-dw_infra_record_reformat-${AB_JOB}.cat > /dev/null 2>&1
m_mkcatalog -catalog GDE-dw_infra_record_reformat-${AB_JOB}.cat
SAVED_CATALOG="${AB_CATALOG}"
export AB_CATALOG;AB_CATALOG='GDE-dw_infra_record_reformat-'"${AB_JOB}"'.cat'
# 
# Initialize condition variables to user-specified conditions
# 
AB_USERCOND_dw_infra_record_reformat=1
AB_IS_LIVE_dw_infra_record_reformat=1
AB_USERCOND_Input_File_1=1
AB_IS_LIVE_Input_File_1=1
AB_HAS_DATA_Flow_9=1
AB_USERCOND_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr=1
AB_IS_LIVE_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr=1
AB_HAS_DATA_Flow_10=1
AB_HAS_DATA_Flow_12=1
AB_USERCOND_Deflate_1="$Deflate_1__condition"
AB_USERCOND_Deflate_1=$(__AB_COND "${AB_USERCOND_Deflate_1}")
AB_IS_LIVE_Deflate_1=1
AB_HAS_DATA_Flow_11=1
AB_USERCOND_Normalized_Output_File_1=1
AB_IS_LIVE_Normalized_Output_File_1=1
AB_USERCOND_Gather_Logs_1=1
AB_IS_LIVE_Gather_Logs_1=1
AB_USERCOND_Make_Log_Dir=1
AB_IS_LIVE_Make_Log_Dir=1
AB_USERCOND_Output_log_file=1
AB_IS_LIVE_Output_log_file=1
AB_HAS_DATA_Flow_20=1
AB_USERCOND_Filter_record_count_rows=1
AB_IS_LIVE_Filter_record_count_rows=1
AB_HAS_DATA_Flow_6=1
AB_USERCOND_Redefine_Format_1=1
AB_IS_LIVE_Redefine_Format_1=1
AB_HAS_DATA_Flow_7=1
AB_USERCOND_Rollup=1
AB_IS_LIVE_Rollup=1
AB_HAS_DATA_Flow_23=1
AB_USERCOND_Record_Count_File=1
AB_IS_LIVE_Record_Count_File=1
AB_USERCOND_Touch_Watch_File=1
AB_IS_LIVE_Touch_Watch_File=1
# 
# Compute condition variables by considering the conditions of neighboring components
# 
done=false
while [ $done = false ] ; do
   done=true
   Temp="${AB_IS_LIVE_Deflate_1}"
   let AB_IS_LIVE_Deflate_1="AB_USERCOND_Deflate_1"
   if [ X"${AB_IS_LIVE_Deflate_1}" != X"$Temp" ]; then
      done=false
   fi
done
# 
if [ X"${AB_VERBOSE_CONDITIONS}" != X"" ]; then
   # 
   # echo condition variables
   # 
   print -r -- 'AB_USERCOND_dw_infra_record_reformat=1'
   print -r -- 'AB_IS_LIVE_dw_infra_record_reformat=1'
   print -r -- 'AB_USERCOND_Input_File_1=1'
   print -r -- 'AB_IS_LIVE_Input_File_1=1'
   print -r -- 'AB_HAS_DATA_Flow_9=1'
   print -r -- 'AB_USERCOND_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr=1'
   print -r -- 'AB_IS_LIVE_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr=1'
   print -r -- 'AB_HAS_DATA_Flow_10=1'
   print -r -- 'AB_HAS_DATA_Flow_12=1'
   print -r -- 'AB_USERCOND_Deflate_1='"${AB_USERCOND_Deflate_1}"
   print -r -- 'AB_IS_LIVE_Deflate_1='"${AB_IS_LIVE_Deflate_1}"
   print -r -- 'AB_HAS_DATA_Flow_11=1'
   print -r -- 'AB_USERCOND_Normalized_Output_File_1=1'
   print -r -- 'AB_IS_LIVE_Normalized_Output_File_1=1'
   print -r -- 'AB_USERCOND_Gather_Logs_1=1'
   print -r -- 'AB_IS_LIVE_Gather_Logs_1=1'
   print -r -- 'AB_USERCOND_Make_Log_Dir=1'
   print -r -- 'AB_IS_LIVE_Make_Log_Dir=1'
   print -r -- 'AB_USERCOND_Output_log_file=1'
   print -r -- 'AB_IS_LIVE_Output_log_file=1'
   print -r -- 'AB_HAS_DATA_Flow_20=1'
   print -r -- 'AB_USERCOND_Filter_record_count_rows=1'
   print -r -- 'AB_IS_LIVE_Filter_record_count_rows=1'
   print -r -- 'AB_HAS_DATA_Flow_6=1'
   print -r -- 'AB_USERCOND_Redefine_Format_1=1'
   print -r -- 'AB_IS_LIVE_Redefine_Format_1=1'
   print -r -- 'AB_HAS_DATA_Flow_7=1'
   print -r -- 'AB_USERCOND_Rollup=1'
   print -r -- 'AB_IS_LIVE_Rollup=1'
   print -r -- 'AB_HAS_DATA_Flow_23=1'
   print -r -- 'AB_USERCOND_Record_Count_File=1'
   print -r -- 'AB_IS_LIVE_Record_Count_File=1'
   print -r -- 'AB_USERCOND_Touch_Watch_File=1'
   print -r -- 'AB_IS_LIVE_Touch_Watch_File=1'
fi

# Files:
mp ifile Input_File_1 $INPUT_FILE
AB_PORT_Input_File_1_read=Input_File_1.read
AB_METADATA_Input_File_1_read=' -metadata metadata1'
mp ofile Normalized_Output_File_1 $OUTPUT_FILE
mp ifile Output_log_file 'file:'"$LOG_FILE"
AB_PORT_Output_log_file_read=Output_log_file.read
AB_METADATA_Output_log_file_read=' -metadata metadata5'
mp ofile Record_Count_File 'file:'"$RECORD_COUNT_FILE"

# Components in phase 0:
mp filter Make_Log_Dir if [[ ! -d $LOG_FILE_DIR ]]
then
   set +e
   mkdir -pm 0775 $LOG_FILE_DIR
   set -e
fi -layout layout1
mp checkpoint 0

# Components in phase 1:
mp reformat-transform Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr -limit 0 -ramp 0.0 -layout Normalized_Output_File_1
mp add-port Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr.out.out0 ${REFORMAT_XFR_FILE:+"$REFORMAT_XFR_FILE"}
AB_PORT_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_out_out0=Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr.out.out0
AB_METADATA_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_out_out0=' -metadata metadata2'
AB_PORT_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_log=Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr.log
AB_METADATA_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_log=' -metadata metadata3'
if [ X"${AB_IS_LIVE_Deflate_1}" != X0 ]; then
   mp broadcast Deflate_1 -compression "$Deflate_1__compression" -layout Normalized_Output_File_1
   AB_PORT_Deflate_1_out=Deflate_1.out
   AB_METADATA_Deflate_1_out=' -metadata metadata4'
else
   AB_PORT_Deflate_1_out="${AB_PORT_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_out_out0}"
   AB_METADATA_Deflate_1_out="${AB_METADATA_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_out_out0}"
   :
fi
mp logger Gather_Logs_1 'file:'"$LOG_FILE" Start End -layout layout2
mp checkpoint 1

# Components in phase 2:
mp select-transform Filter_record_count_rows 'string_index(line, "bytes) written") > 0' -limit 0 -ramp 0.0 -layout Record_Count_File
AB_PORT_Filter_record_count_rows_out=Filter_record_count_rows.out
AB_METADATA_Filter_record_count_rows_out=' -metadata metadata5'
mp copy Redefine_Format_1 -layout Record_Count_File
AB_PORT_Redefine_Format_1_out=Redefine_Format_1.out
AB_METADATA_Redefine_Format_1_out=' -metadata metadata6'
mp rollup Rollup '{}' "${_AB_PROXY_DIR}"'/Rollup-8.xfr' -limit 0 -ramp 0.0 -check-sort -layout Record_Count_File
AB_PORT_Rollup_out=Rollup.out
AB_METADATA_Rollup_out=' -metadata metadata7'
mp checkpoint 2

# Components in phase 3:
mp filter Touch_Watch_File touch $WATCH_FILE -layout layout2

# Flows for Entire Graph:
mp straight-flow Flow_9 "${AB_PORT_Input_File_1_read}" Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr.in${AB_METADATA_Input_File_1_read}
let AB_FLOW_CONDITION="AB_IS_LIVE_Deflate_1"
if [ X"${AB_FLOW_CONDITION}" != X0 ]; then
   mp straight-flow Flow_10 "${AB_PORT_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_out_out0}" Deflate_1.in${AB_METADATA_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_out_out0}
fi
mp straight-flow Flow_11 "${AB_PORT_Deflate_1_out}" Normalized_Output_File_1.write${AB_METADATA_Deflate_1_out}
mp fan-in-flow Flow_12 "${AB_PORT_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_log}" Gather_Logs_1.in${AB_METADATA_Reformat_data_based_on_DW_XFR_ETL_ID_reformat_xfr_log}
mp straight-flow Flow_20 "${AB_PORT_Output_log_file_read}" Filter_record_count_rows.in${AB_METADATA_Output_log_file_read}
mp straight-flow Flow_6 "${AB_PORT_Filter_record_count_rows_out}" Redefine_Format_1.in${AB_METADATA_Filter_record_count_rows_out}
mp straight-flow Flow_7 "${AB_PORT_Redefine_Format_1_out}" Rollup.in${AB_METADATA_Redefine_Format_1_out}
mp straight-flow Flow_23 "${AB_PORT_Rollup_out}" Record_Count_File.write${AB_METADATA_Rollup_out}

if [ X"${AB_VERBOSE_CONDITIONS}" != X"" ]; then
   print -r -- 'Generated graph:'
   mp show
fi
unset AB_COMM_WAIT
export AB_TRACKING_GRAPH_THUMBPRINT;AB_TRACKING_GRAPH_THUMBPRINT=978304
mp run
mpjret=$?
unset AB_COMM_WAIT
unset AB_TRACKING_GRAPH_THUMBPRINT
mp reset
m_rmcatalog > /dev/null 2>&1
export XX_CATALOG;XX_CATALOG="${SAVED_CATALOG}"
export AB_CATALOG;AB_CATALOG="${SAVED_CATALOG}"

#+Script End+  ==================== Edits in this section are preserved.
. /dw/etl/mstr_cfg/etlenv.setup









#+End Script End+  ====================

exit $mpjret
